static char sccsid[] = "@(#)14	1.14  src/bos/usr/sbin/lsdev/lscfprt.c, cmdcfg, bos411, 9428A410j 11/16/93 16:53:36";
/*
 * COMPONENT_NAME: (CMDCFG)  Generic config support cmds
 *
 * FUNCTIONS: 
 * 	istrcmp() rprint() rinit() rlist()
 * 	DOprint() EOprint() Rprint() print_range() print_list()
 * 	Finit() Fparse() * fmtcol() * Fprintcolval() Fgetcolvalsize()
 * 	Fgetcolhdrsize() Fprintcolhdr() get_subclass() 
 * 	get_nls() fclean()
 *
 * ORIGINS: 27
 *
 * IBM CONFIDENTIAL -- (IBM Confidential Restricted when
 * combined with the aggregated modules for this product)
 *                  SOURCE MATERIALS
 * (C) COPYRIGHT International Business Machines Corp. 1989, 1993
 * All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */
#include <stdio.h>
#include <ctype.h>
#include "hlcmds.h"
#include "lscf.h"

extern char *cmdname;

char *malloc();
char *realloc();

/*
 *   NAME:     istrcmp
 *   FUNCTION: indirect string compare, used by rprint as the comparison
 *	       function handed to qsort to sort the unique values.
 *		 
 */
istrcmp(a,b)
char **a,**b;
{
	return(strcmp(*a,*b));
}

/*
 *   NAME:     rprint
 *   FUNCTION: sort print the list of unique values generated by the -r 
 *		option
 */
rprint()
{
int i;
	if(nvalues)
		qsort(values,nvalues,sizeof(char **),istrcmp);
	if(print_hdr)
		printf("%s:\n",entry_col);
	for(i=0;i<nvalues;i++){
		printf("%s%s\n",
			(print_hdr? "   " : "" ),
			values[i]);
		}
}
/*
 *   NAME:     rinit
 *   FUNCTION: with the range of values display (-r) option,
 *	       initialize the values list, before calling rlist
 *	       for each object
 */
rinit()
{
	nvalues = 0;
	values = NULL;
}
/*
 *   NAME:     rlist
 *   FUNCTION: with the -r option, each call to this adds the string
 *	       printed value of the given column of the given object
 *             to the list, if it differs from the other objects
 *	       already in the list.
 */
rlist(mode,cobj,colname)
int mode;
char *cobj;
char *colname;
{
int i,rv;
char linebuf[BUFSIZE];
char *vp;

	linebuf[0] = '\0';
	switch(mode){
		case PdCn_MODE:
			rv = fmtcol( PRINTVAL,linebuf,PdCn_CLASS,
				0,colname,cobj);
			break;
		case PdDv_MODE:
			rv = fmtcol( PRINTVAL,linebuf,PdDv_CLASS,
				0,colname,cobj);
			break;
		case CuDv_MODE:
			rv = fmtcol(PRINTVAL,linebuf, CuDv_CLASS,
					0,colname, cobj);
			if(!rv)
				rv = fmtcol(PRINTVAL,linebuf, PdDv_CLASS, 
					0,colname,
					((struct CuDv *)cobj)->PdDvLn);
			break;
		}
	if(!rv){
		sprintf(msg,"'%s'",colname);
		error1(CFG_ODM_COL_ERR,msg);
		}
				/* no printable value */
	if(!linebuf[0])
		return;
	for(i=0;i<nvalues;i++){
		if(!strcmp(linebuf,*(values + i)))
			break;
		}
				/* not found */
	if(i == nvalues){
		if(!nvalues)
			values = (char **)
				malloc(sizeof (char **));
		else 
			values = (char **)
				realloc(values,
					(nvalues+1)*(sizeof (char **)));
		if(!values)
			error(CFG_MALLOC_FAILED);
		vp = malloc(strlen(linebuf) + 1);
		if(!vp)
			error(CFG_MALLOC_FAILED);
		strcpy(vp,linebuf);
		values[i] = vp;
		nvalues++;
		}
}
   
/*
 *   NAME:     DOprint
 *   FUNCTION: print routine for the  -D and -O  option combiation.
 *             This is called to show the names and default values of
 *	       attributes in the form (e.g.)
 *                      #attrname1:attrname2:attrname3
 *                      deflt1:deflt2:deflt3
 */
DOprint()
{
int i;
	printf("#");
	for(i=0;i<nattrs;i++){
		if(i!=0)printf(":");
		printf("%s", combined_attr[i].pd->attribute);
		}
	printf("\n");
	for(i=0;i<nattrs;i++){
		if(i!=0)printf(":");
		printf("%s", combined_attr[i].pd->deflt);
		}
	printf("\n");
}

/*
 *   NAME:     EOprint
 *   FUNCTION: print routine for the  -E and -O  option combiation.
 *             This is called to show the names and effective values of
 *	       attributes in the form (e.g.)
 *                      #attrname1:attrname2:attrname3
 *                      effvalue1:effvalue2:effvalue3
 *             If a value contains a colon, prefix it with "#!" to make "#!:".
 *             ie:   wy:50   to    wy#!:50
 */
EOprint()
{
int i;
	printf("#");
	for(i=0;i<nattrs;i++){
		if(i!=0)printf(":");
		printf("%s", combined_attr[i].pd->attribute);
		}
	printf("\n");
	for(i=0;i<nattrs;i++) {
		char tstr[DEFAULTSIZE], *optr, *nptr;
		if(i!=0)printf(":");
		optr = combined_attr[i].cu 
			? combined_attr[i].cu->value
			: combined_attr[i].pd->deflt;
		nptr = strchr( optr,':');
		if ( ! nptr )
			printf("%s", optr);
		else {
			strcpy(tstr,optr);
			optr = tstr;
			/* 
			 * Check for colon in value string.
			 */
			while ( optr ) {
				nptr = strchr( optr,':');
				if ( nptr ) {
				/* 
				 * Quote colon with #!
				 */
					*nptr = '\0';
					printf("%s#!:",optr);
					optr = nptr + 1;
				}
				else {
					printf("%s",optr);
					optr = '\0';
				}
			}
		}
	}
	printf("\n");
}

/*
 *   NAME:     Rprint
 *   FUNCTION: print routine for the  -R option.
 *             This is called to show the range or list of legal values
 *	       of an attribute.
 */
Rprint()
{
int i;
	   for(i=0;   i<nattrs;   i++){
		if(strchr(combined_attr[i].pd->rep,'r')){
			print_range(combined_attr[i].pd->attribute,
				combined_attr[i].pd->values);
			}
		else if(strchr(combined_attr[i].pd->rep,'l')){
			print_list(combined_attr[i].pd->values);
			}
		else {
			printf("%s\n",
				combined_attr[i].pd->values);
			}
		}
}
/*
 *       NAME: print_range
 *	 DESCRIPTION: 
 *              print the range of possible values of a predefined
 *              attribute of representation type "r" in the form:
 *                     begin...end(+increment)
 */
print_range(name,str)
char *str;
{
long begin,end,inc;
char *mp,*cp,*ep;
	if(cp = strchr(str,'\n'))
		*cp = '\0';

	cp = strchr(str,',');
	if(!cp) {
		sprintf(msg,"%s=%s",name,str);
		error1(CFG_BAD_ATTR,msg);
		}
	*cp = '\0';
	mp = strchr(str,'-');
	if(!mp){
		sprintf(msg,"%s=%s",name,str);
		error1(CFG_BAD_ATTR,msg);
		}
	*mp = '\0';
	begin = strtol(str,&ep,0);
	if(begin == 0 && *ep != '\0' && *ep != ' ' && *ep != '\t'){
		sprintf(msg,"%s %s",name,str);
		error1(CFG_BAD_ATTR,msg);
		}
	end = strtol(mp+1,&ep,0);
	if(end == 0 && *ep != '\0' && *ep != ' ' && *ep != '\t'){
		sprintf(msg,"%s %s",name,str);
		error1(CFG_BAD_ATTR,msg);
		}
	inc = strtol(cp+1,&ep,0);
	if(inc == 0 && *ep != '\0' && *ep != ' ' && *ep != '\t'){
		sprintf(msg,"%s %s",name,str);
		error1(CFG_BAD_ATTR,msg);
		}
	if(inc <0){
		sprintf(msg,"%s %s",name,str);
		error1(CFG_BAD_ATTR,msg);
		}

	printf("%s...%s (+%s)\n",str,mp+1,cp+1);
}
/*
 *       NAME: print_list
 *	 DESCRIPTION: list the possible values of a predefined
 *              attribute of representation type "l" with
 *		one possible value per line.
 */
print_list(str)
char *str;
{
char *cp;
	cp = str;
	while(1){
		switch(*cp){
		case ',':
			putchar('\n');
			break;
		default :
			putchar(*cp);
			break;
		case '\0':
			break;
			}
		if(!*cp)break;
		++cp;
		}
	putchar('\n');
}

/*
 *   NAME:     Finit
 *   FUNCTION: 
 *	       initialize the formatted print routines.
 */
Finit()
{
	bzero(col_sz,sizeof(col_sz));
	if(strchr(entry_fmt,' '))
		columnize = TRUE;
	else
		columnize = FALSE;
}

/*
 *   NAME:     Fparse
 *   FUNCTION: 
 *	       parse a format string, and for each columnname identified,
 *	       run a subroutine against the given object, passing the
 *	       subroutine a mode variable to tell it what to do.
 *             In this way we can make multiple passes through the 
 *	       format string. If we are going to print in aligned columns,
 *             first we find the sizes of the fields in the
 *	       header, then in each object, keeping a running maximum.  
 *             This is then used to print the header and the values for
 *             each object.
 *	       
 */
Fparse(purpose,mode,cobj)
int purpose;
int mode;
char *cobj;
{
int col;
int span,rv;
char tmp[BUFSIZE];
char seperator[BUFSIZE];
char colname[BUFSIZE];
char *cp;
char linebuf[BUFSIZE];


	linebuf[0] = '\0';
	cp = entry_fmt;
	col = -1 ;
	while(*cp){
	        if(span = strcspn(cp,name_chars)){
			memcpy(seperator,cp,span);
			seperator[span] = '\0';
			sprintf(tmp,"%s",seperator);
			strcat(linebuf,tmp);
			cp += span;
			}
		if(span = strspn(cp,name_chars)){
			++col;
			if(col == MAX_FCOLS){
				error1(CFG_MISC_SYNTAX_ERR,"-F");
				}
			strncpy(colname,cp,span);
			colname[span] = '\0';
			cp += span;
			switch(mode){
			case PdCn_MODE:
				rv = fmtcol( purpose,linebuf,PdCn_CLASS,
					col,colname,cobj);
				break;
			case PdDv_MODE:
				rv = fmtcol( purpose,linebuf,PdDv_CLASS,
					col,colname,cobj);
				break;
			case CuDv_MODE:
				rv = fmtcol( purpose,linebuf,CuDv_CLASS,
					col,colname, cobj);
				if(!rv)
					if(!(int)
						(((struct CuDv *)cobj)->PdDvLn))
						rv = 1;
					else
					{
						rv = fmtcol(purpose,
							linebuf,PdDv_CLASS,
							 col,colname,
					   ((struct CuDv *)cobj)->PdDvLn);
					}
				break;
			case Attr_MODE:
				rv = fmtcol(purpose,linebuf,CuAt_CLASS,
					col,colname,
					((struct CombinedAttr *)cobj)->cu);
				if(!rv)
					if(!(int) (((struct
						CombinedAttr *)cobj)->pd))
						rv = 1;
					else
					{
						rv = fmtcol(purpose,
						    linebuf,PdAt_CLASS, 
						    col,colname,
					    ((struct CombinedAttr *)cobj)->pd);
					}
				break;
			default:
				exit(-1);
			}
			if(!rv){
				sprintf(msg,"'%s'",colname);
				error1(CFG_ODM_COL_ERR,msg);
				}
			}
		}
			/* chop out trailing spaces */
	if(linebuf[0]){
		cp = linebuf + strlen(linebuf) -1;
		while (*cp == ' ')*cp-- = '\0';
		}

	if(purpose == PRINTHDR || purpose == PRINTVAL){
		printf("%s\n",linebuf);
		fflush(stdout);
		}
}

/*
 *   NAME:     fmtcol
 *   FUNCTION: 
 *	       dispatch routine for Fparse, which calls specific
 *	       routines with particular objects, depending on
 *             the purpose.
 *   RETURNS:  what the routine it called returned
 */
fmtcol(purpose,linebuf,classp,col,colname,cobj)
int purpose;
char *linebuf;
struct Class *classp;
int col;
char *colname;
char *cobj;			/* address of the memory object */
{
	switch(purpose){
		case GETHDRSZ:
			return Fgetcolhdrsize(col,colname);
		case GETVALSZ:
			if(!cobj) return FALSE;
			return Fgetcolvalsize(classp,col,colname,cobj);
		case PRINTHDR: 
			return Fprintcolhdr(linebuf,col,colname);
		case PRINTVAL: 
			if(!cobj) return FALSE;
			return Fprintcolval(linebuf,classp,col,colname,cobj);
		default:
			error1(CFG_INTERNAL_ERR,"fmtcol()");
		}
}
/*
 *   NAME:     Fprintcolval
 *   FUNCTION: sprint the value of a given column of a given object
 *             into a buffer provided by the caller.
 *             If the "columnize" flag is set,
 *             use a field of a previously calculated size for the column.
 *   INPUT:    linebuf,classp,col,colname,m
 *   RETURNS:  TRUE if column was found
 *             FALSE if column was not found
 *   NOTE:     some special cases for "pseudo columns"
 *             Implementation of  effective value for attributes.
 *                For the columnname "value", if class is Predefined Attr
 *                we did not have a customized value, so use
 *                the column "deflt".
 *             user_settable for attributes characteristic.
 *                For the columnname "user_settable",
 *                with class Predefined Attribute, use the existence
 *                of the character 'U' in the generic flags field to
 *                print TRUE or FALSE.
 *             description for Predefined Device and Predefined Attr
 *                call a subroutine to get the proper string
 */
Fprintcolval(linebuf,classp,col,colname,m)
char *linebuf;
struct Class *classp;
int col;
char *colname;
char *m;		/* address of the memory object */
{
char *effcolname;
char *cp;
char tmp[BUFSIZE];
char spec[64];
int i;
int found;
	    found = FALSE;
	    if(!strcmp(colname,"value") && classp == PdAt_CLASS )
		effcolname = "deflt";
	    else
		effcolname = colname;
			
	/* This for loop interpretively references the ODM, 
			using the Class and Classelem structs */

				/* for special cases only */
	   if(columnize)
	   	sprintf(spec,"%%-%ds",col_sz[col]);
	   else
	   	strcpy(spec,"%s");

				/* special case for state */
	   if(classp == CuDv_CLASS && !strcmp(colname,"status")){
		switch(((struct CuDv *)m)->status){
			case  DEFINED:
				cp = MSGSTR(CFG_MSG_DEFINED);
				break;
			case  AVAILABLE:
				cp = MSGSTR(CFG_MSG_AVAILABLE);
				break;
			case  STOPPED:
				cp = MSGSTR(CFG_MSG_STOPPED);
				break;
			case DIAGNOSE:
				cp = MSGSTR(CFG_MSG_DIAGNOSE);
				break;
			default:
				cp = MSGSTR(CFG_MSG_UNKNOWN);
				break;
			}
		sprintf(tmp,spec,cp);
		found = TRUE;
	        }

	    else {
	     for(i=0;i<classp->nelem;i++) {
	      if(!strcmp(classp->elem[i].elemname,effcolname)){
		switch((classp->elem)[i].type)
		{
		case ODM_LONG:
		    if(columnize)
		    	sprintf(spec,"%%%dld",col_sz[col]);
		    else
		    	strcpy(spec,"%ld");
		    sprintf(tmp,spec,
			*(long *)(m + (classp->elem)[i].offset));
		    break;
		case ODM_SHORT:
		    if(columnize)
		    	sprintf(spec,"%%%dhd",col_sz[col]);
		    else
		    	strcpy(spec,"%hd");
		    sprintf(tmp,spec,
		    *(short *)(m + (classp->elem)[i].offset));
		    break;
		case ODM_LINK:
		    if(columnize)
		    	sprintf(spec,"%%-%ds",col_sz[col]);
		    else
		    	strcpy(spec,"%s");
		    sprintf(tmp,spec, (char *)
		        (m+(classp->elem)[i].offset+2*sizeof(char *)));
		    break;
		case ODM_CHAR:
		case ODM_LONGCHAR:
		case ODM_METHOD:
		    if(columnize)
		    	sprintf(spec,"%%-%ds",col_sz[col]);
		    else
		    	strcpy(spec,"%s");
		    sprintf(tmp,spec,
				(char *)(m + (classp->elem)[i].offset));
		    break;
		case ODM_VCHAR:
		    if(columnize)
		    	sprintf(spec,"%%-%ds",col_sz[col]);
		    else
		    	strcpy(spec,"%s");
		    if( cp = *(char **)(m + (classp->elem)[i].offset))
		       	sprintf(tmp,spec,cp);
		    else
			sprintf(tmp,spec,"");
		    break;
		}
		found = TRUE;
		break;
	      }
	    }
	if(i == classp->nelem){
	   if(columnize)
	   	sprintf(spec,"%%-%ds",col_sz[col]);
	   else
	    	strcpy(spec,"%s");
	   if(classp == PdDv_CLASS || classp == CuDv_CLASS){
		if(!strcmp(colname,"description")){
		    sprintf(tmp,spec,get_dev_desc(classp,m));
		    found = TRUE;
		    }
		else return FALSE;
	        }
	   else if(classp == PdAt_CLASS){ 
		if(!strcmp(colname,"description")){
		    sprintf(tmp,spec,get_at_desc(m));
		    found = TRUE;
		    }
		else if(!strcmp(colname,"user_settable")){
		    sprintf(tmp,spec,
				strchr(
				((struct PdAt *)m)->generic,'U')
				?MSGSTR(CFG_MSG_TRUE)
				:MSGSTR(CFG_MSG_FALSE) );
		    found = TRUE;
		    }
		else return FALSE;
		}
	   else 
		return FALSE;
	   }
	  }

	if(found){
		strcat(linebuf,tmp);
		return TRUE;
		}
	else
		return FALSE;
}
/*
 *   NAME:     Fgetcolvalsize
 *   FUNCTION: get the length of the printed value of a given column 
 *             a given object, and compare it to the maximum size of that
 *             column so far, recorded in the global array col_sz.
 *             If it is larger, increase the column size.
 *   RETURNS:  TRUE if column was found
 *             FALSE if column was not found
 *   NOTE:     some special cases for "pseudo columns"
 *             Implementation of  effective value for attributes.
 *                For the columnname "value", if class is Predefined Attr
 *                we did not have a customized value, use column "deflt".
 *             user_settable for attributes characteristic.
 *                For the columnname "user_settable",
 *                with class Predefined Attribute, use the existence of
 *                character 'U' in the generic flags field to print 
 *                TRUE or FALSE.
 *             description for Predefined Device and Predefined Attr
 *                call a subroutine to get the proper string
 */
Fgetcolvalsize(classp,col,colname,m)
struct Class *classp;
int col;
char *colname;
char *m;		/* address of the memory object */
{
char *effcolname;
char *cp;
char tmp[BUFSIZE];
int i,len;
	    if(!strcmp(colname,"value") && classp == PdAt_CLASS )
		effcolname = "deflt";
	    else
		effcolname = colname;

	/* This for loop interpretively references the ODM, 
			using the Class and Classelem structs */

				/* special case for state */
	   if(classp == CuDv_CLASS && !strcmp(colname,"status")){
		switch(((struct CuDv *)m)->status){
			case  DEFINED:
				cp = MSGSTR(CFG_MSG_DEFINED);
				break;
			case  AVAILABLE:
				cp = MSGSTR(CFG_MSG_AVAILABLE);
				break;
			case  STOPPED:
				cp = MSGSTR(CFG_MSG_STOPPED);
				break;
			default:
				cp = MSGSTR(CFG_MSG_UNKNOWN);
				break;
			}
		sprintf(tmp,"%s",cp);
	        }

	    else {
	    for(i=0;i<classp->nelem;i++){
	      if(!strcmp(classp->elem[i].elemname,effcolname)){
		switch((classp->elem)[i].type) {
			case ODM_LONG:
			    sprintf(tmp,"%d",
				*(long *)(m + (classp->elem)[i].offset));
		    	    break;
			case ODM_SHORT:
			    sprintf(tmp,"%hd",
			    	*(short *)(m + (classp->elem)[i].offset));
		    	    break;
			case ODM_LINK:
			    sprintf(tmp,"%s", (char *)
			        (m+(classp->elem)[i].offset+2*sizeof(char *)));
		    	    break;
			case ODM_CHAR:
			case ODM_LONGCHAR:
			case ODM_METHOD:
			     sprintf(tmp,"%s",
				(char *)(m + (classp->elem)[i].offset));
		    	     break;
			case ODM_VCHAR:
			     if( cp = *(char **)(m + (classp->elem)[i].offset))
		        	sprintf(tmp,"%s",cp);
			     else
				sprintf(tmp,"");
			     break;
			}
		    break;
		}
	      }
	if(i == classp->nelem){
	    if(classp == PdDv_CLASS || classp == CuDv_CLASS){
		if(!strcmp(colname,"description")){
		    sprintf(tmp,"%s",get_dev_desc(classp,m));
		    }
		else return FALSE;
		}
	    else if(classp == PdAt_CLASS){ 
		if(!strcmp(colname,"description"))
		    sprintf(tmp,"%s",get_at_desc(m));
		else if(!strcmp(colname,"user_settable"))
		    sprintf(tmp,"%s",
				strchr(
				((struct PdAt *)m)->generic,'U')
				?"TRUE":"FALSE");
		else return FALSE;
		}
	    else 
		return FALSE;
		
	    }
	   }
	len = strlen(tmp);
	if(len > col_sz[col])
		col_sz[col] = len;
	return TRUE;
}
/*
 *   NAME:     Fgetcolhdrsize
 *   FUNCTION: 
 *             get the length of the printed name of a given column,
 *             compare it to the maximum size of that
 *             column so far, recorded in the global array col_sz.
 *             If it is larger, increase the column size.
 *   RETURNS:  TRUE
 */
Fgetcolhdrsize(col,colname)
int col;
char *colname;
{
int len;
	len = strlen(colname);
	if(len > col_sz[col])
		col_sz[col] = len;
	return TRUE;
}
/*
 *   NAME:     Fprintcolhdr
 *   FUNCTION: sprint the name of a given column of a given object
 *             into a buffer provided by the caller.
 *             If the "columnize" flag is set,
 *             use a field of a previously calculated size for the column.
 *   RETURNS:  TRUE
 */
Fprintcolhdr(linebuf,col,colname)
char *linebuf;
int col;
char *colname;
{
char spec[64];
char tmp[BUFSIZE];
	if(columnize)
	    	sprintf(spec,"%%-%ds",col_sz[col]);
	else
	    	strcpy(spec,"%s");
	sprintf(tmp,spec,colname);
	strcat(linebuf,tmp);
	return TRUE;
}
/*
 *   NAME:     get_subclass
 *   FUNCTION: return a pointer to the subclass of a customized device.
 *   NOTE:     this routine is only used when there is
 *             only one customized device in the cudv list.
 */
char *
get_subclass()
{
struct PdDv *p;
	if(cudv){
		p = cudv->PdDvLn;
		return(p->subclass);
		}
	else
		error1(CFG_ODM_ACCESS,"CuDv");
}
/*
 *   NAME:     get_nls
 *   FUNCTION: return nls string
 *             
 */
char *
get_nls()
{
	return("Unknown NLS");
}
/*
 *   NAME:     fclean
 *   FUNCTION: do cleanup required for error exits.
 *             
 */
fclean()
{
	odm_terminate();
}

