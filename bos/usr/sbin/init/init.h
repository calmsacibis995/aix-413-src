/* @(#)13	1.31  src/bos/usr/sbin/init/init.h, cmdoper, bos411, 9428A410j 5/9/94 16:39:52 */
/*
 * COMPONENT_NAME: (CMDOPER) commands needed for basic system needs
 *
 * FUNCTIONS: 
 *
 * ORIGINS: 3, 27
 *
 * This module contains IBM CONFIDENTIAL code. -- (IBM
 * Confidential Restricted when combined with the aggregated
 * modules for this product)
 *                  SOURCE MATERIALS
 * (C) COPYRIGHT International Business Machines Corp. 1989, 1994
 * All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 *
 */

/*	In case of bugs, there are four flavors of debug available.	*/
/*									*/
/*	UDEBUG		Will generate a version of "init" that can	*/
/*			be run as a user process.  In this form,	*/
/*			certain signals will cause core dumps and	*/
/*			and a file called "debug" is written in the	*/
/*			directory where "init" was started.  It also	*/
/*			reads the local directory for utmp, inittab	*/
/*			and the other files it usually gets from	*/
/*			/etc.						*/
/*									*/
/*	XDEBUG		Generates an "init" which runs in the usual	*/
/*			way, but generates a file, /etc/debug, with	*/
/*			information about process removal, level	*/
/*			changes, and accounting.			*/
/*									*/
/*	DEBUG1		This symbol adds more debug to what would be	*/
/*			generated by XDEBUG or UDEBUG.  It has		*/
/*			detailed information about each process		*/
/*			spawned from inittab.  DEBUG1 by itself is	*/
/*			equivalent to XDEBUG and DEBUG1.  It can be	*/
/*			added to UDEBUG to get a user process version.	*/
/*									*/
/*	ACCTDEBUG	Generate debug from the accounting program	*/
/*			only.						*/
/*									*/
/* There are two compile-time options available for your perusal:     */
/*									*/
/*	CSECURITY	NCSC "Orange Book" security code.		*/
/*			This code has hooks throughout the code,	*/
/*			including the kernel. Use accordingly.		*/
/*									*/
/*	MAXLOGINS in real life */
/*	TOTLOGIN=n	Limits total simultaneous logins on a 		*/
/*			multi-user level system to whatever number	*/
/* 			this is defined as. The number INCLUDES		*/
/*			hft/virtual terminal >>logins<<.		*/
/*			NOTE: The 'login' utility MUST be compiled	*/
/*			the same way if this option is used.		*/
/*									*/

#ifdef	ACCTDEBUG
#define	DEBUGGER
#endif

#ifdef	XDEBUG
#ifndef	DEBUGGER
#define	DEBUGGER
#endif
#endif

#ifdef	UDEBUG
#ifndef	XDEBUG
#define	XDEBUG
#endif
#ifndef	ACCTDEBUG
#define	ACCTDEBUG
#endif
#ifndef	DEBUGGER
#define	DEBUGGER
#endif
#endif

#ifdef	DEBUG1
#ifndef	XDEBUG
#define	XDEBUG
#endif
#ifndef	ACCTDEBUG
#define	ACCTDEBUG
#endif
#ifndef	DEBUGGER
#define	DEBUGGER
#endif
#endif

#ifdef CSECURITY
#define	HFT	1
#define	TTY	0
#define	TSHON	1
#define	TSHOFF	0
#define	ACTBHFT	"/dev/hft"
#endif

#define	FAILURE	-1
#define SPACE	0x20
#define	TAB	0x09
#define	NL	0x0a
#define MINUS	'-'

/*	SLEEPTIME	The "number of seconds 'init' sleeps between	*/
/*			wakeups if nothing else requires this 'init'"	*/
/*			wakeup.						*/
/*	MAXCMDL		The maximum length of a command string in	*/
/*			/etc/inittab.					*/
/*	EXEC		The length of the prefix string added to all	*/
/*			commands found in /etc/inittab.			*/
/*	TWARN		The amount of time between warning signal,	*/
/*			SIGTERM, and the fatal kill signal, SIGKILL.	*/
/*	WARNFREQUENCY	The number of consecutive failures to find an	*/
/*			empty slot in "init's" internal "proc_table"	*/
/*			before another error message will be generated.	*/
#define	SLEEPTIME	1*60
#define	MAXCMDL	1024
#define IDENT_LEN 14	/* Length of identifier field in inittab */
#define	EXEC	(sizeof("exec ") - 1)
#define	TWARN	15
#define	WARNFREQUENCY	25
#define	LCLOSE	10	/* last file descriptor to close before exec'ing programs */

/*	Correspondence of signals to init actions.			*/
#define LVLQ	SIGHUP
#define	LVL0	SIGINT
#define	LVL1	SIGQUIT
#define	LVL2	SIGILL
#define	LVL3	SIGTRAP
#define	LVL4	SIGIOT
#define	LVL5	SIGEMT
#define	LVL6	SIGFPE
#define	LVL7	SIGTTIN
#define	LVL8	SIGTTOU
#define	LVL9	SIGIO
#define	SINGLE_USER	SIGBUS
#define LVLN	SIGWINCH
#define	LVLa	SIGSEGV
#define	LVLb	SIGSYS
#define	LVLc	SIGPIPE

/*	Bit Mask for each level.  Used to determine legal levels.
	Init code assumes no gaps between MASK0 and MASKSU.	*/
#define	MASK0	0x0001
#define	MASK1	0x0002
#define	MASK2	0x0004
#define	MASK3	0x0008
#define	MASK4	0x0010
#define	MASK5	0x0020
#define	MASK6	0x0040
#define	MASK7	0x0080
#define	MASK8	0x0100
#define	MASK9	0x0200
#define	MASKSU	0x0400
#define MASKN	0x0800	/* note gap for 1 new code */
#define	MASKa	0x2000
#define	MASKb	0x4000
#define	MASKc	0x8000

/*	Legal action field values.					*/
/* Kill process if on, otherwise ignore */
#define	OFF		0
/* Continually restart process when it dies */
#define	RESPAWN		1
/* Respawn for a,b,c type processes */
#define	ONDEMAND	RESPAWN
/* Start process.  Do not respawn when dead */
#define	ONCE		2
/* Perform once and wait to complete */
#define	WAIT		3
/* Start at boot time only */
#define	BOOT		4
/* Start at boot time and wait for complete */
#define	BOOTWAIT	5
/* Start on powerfail */
#define	POWERFAIL	6
/* Start and wait for complete on powerfail */
#define	POWERWAIT	7
/* Default level "init" should start at. */
#define	INITDEFAULT	8
/* Actions performed before init speaks. */
#define	SYSINIT		9

#define	M_OFF		0001
#define	M_RESPAWN	0002
#define	M_ONDEMAND	M_RESPAWN
#define	M_ONCE		0004
#define	M_WAIT		0010
#define	M_BOOT		0020
#define	M_BOOTWAIT	0040
#define	M_PF		0100
#define	M_PWAIT		0200
#define	M_INITDEFAULT	0400
#define M_SYSINIT	01000
#define M_HOLD		02000


/*	Init can be in either of three main states, "normal" mode	*/
/*	where it is processing entries for the lines file in a normal	*/
/*	fashion, "boot" mode, where it is only interested in the boot	*/
/*	actions, and "powerfail" mode, where it is only interested in	*/
/*	powerfail related actions.  The following masks declare the	*/
/*	legal actions for each mode.					*/
#define	NORMAL_MODES	(M_OFF | M_HOLD | M_RESPAWN | M_ONCE | M_WAIT)
#define	BOOT_MODES	(M_BOOT | M_BOOTWAIT)
#define	PF_MODES	(M_PF | M_PWAIT)

#define	ID	1
#define	LEVELS	2
#define	ACTION	3
#define	COMMAND	4

/***************************************************
* process ids
* process numbers
* Init's internal proc table
***************************************************/
#define	id_eq(x,y)	(strncmp(x, y, IDENT_LEN) ? FALSE : TRUE)
#ifdef UDEBUG
pid_t SPECIALPID;	/* Any pid can be made special for debugging */
#else
/* Normally the special pid is process 1 */
#define	SPECIALPID	1
#endif

#undef NPROC
extern int NPROC;

struct PROC_TABLE {
	char p_id[IDENT_LEN];	/* unique id of process */
	short p_count;	/* How many respawns of command in current series. */
	pid_t p_pid;	/* Process id */
	time_t p_time;	/* Start time for a series of respawns */
	short p_flags;
	short p_exit;	/* Exit status of a process which died */
};

extern struct PROC_TABLE *proc_table;	/* Table of active processes */
struct PROC_TABLE	dummy;	/* A zero table used when calling "account"
				   for non-process type accounting. */
#define	NULLPROC	((struct PROC_TABLE *)(0))
#define	NO_ROOM		((struct PROC_TABLE *)(FAILURE))

extern int *orphan_tab;		/* table of orphan processes */
int orphan_cnt = 0;
int more_dead_children;         /* flag indicating orphan_tab filled up */

/*	Flags for the "p_flags" word of a proc_table entry.		*/
/*									*/
/*	OCCUPIED		This slot in init's proc table is in	*/
/*					use.				*/
/*	LIVING			Process is alive.			*/
/*	NOCLEANUP		"efork()" is not allowed to cleanup	*/
/*					this entry even if process is	*/
/*					dead.				*/
/*	NAMED			This process has a name, i.e. came from	*/
/*					/etc/inittab.			*/
/*	DEMANDREQUEST		Process started by a "telinit [abc]"	*/
/*					command.  Processes formed this	*/
/*					way are respawnable and immune	*/
/*					to level changes as long as	*/
/*					their entry exists in inittab.	*/
/*	TOUCHED			Flag used by "remove" to determine	*/
/*					whether it has looked at an	*/
/*					entry while checking for	*/
/*					processes to be killed.		*/
/*	WARNED			Flag used by "remove" to mark processes	*/
/*					that have been sent the		*/
/*					SIGTERM signal.  If they don't	*/
/*					die in 30 seconds, they will	*/
/*					be sent the SIGKILL signal.	*/
/*	KILLED			Flag used by "remove" to say that a	*/
/*					process has been sent both	*/
/*					kill signals.  Such processes	*/
/*					should die immediately, but in	*/
/*					case they don't, this prevents	*/
/*					"init" from trying to kill it	*/
/*					again and again, and hogging	*/
/*					the process table of the	*/
/*					operating system.		*/
#define	OCCUPIED	01
#define	LIVING		02
#define	NOCLEANUP	04
#define	NAMED		010
#define	DEMANDREQUEST	020
#define	TOUCHED		040
#define	WARNED		0100
#define	KILLED		0200

/*	Respawn limits for processes that are to be respawned.		*/
/*									*/
/*	SPAWN_INTERVAL		The number of seconds over which	*/
/*				"init" will try to respawn a process	*/
/*				SPAWN_LIMIT times before it gets mad.	*/
/*									*/
/*	SPAWN_LIMIT		The number of respawns "init" will	*/
/*				attempt in SPANW_INTERVAL seconds	*/
/*				it generates an error message and	*/
/*				inhibits further tries for INHIBIT	*/
/*				seconds.				*/
/*									*/
/*	INHIBIT			The number of seconds "init" ignores	*/
/*				an entry it had trouble spawning	*/
/*				unless a "telinit Q" is received.	*/
#define	SPAWN_LIMIT	5
#define	SPAWN_INTERVAL	(SPAWN_LIMIT * 45)
#define	INHIBIT		(SPAWN_INTERVAL * 5)

/***********************************
* This is the command fields struc 
* read in from the inittab file entry.
***********************************/
struct CMD_LINE {
	char 	c_id[IDENT_LEN];/* unique id of process to be affected */
	int 	c_levels;	/* Mask of legal levels for process */
	short 	c_action;	/* Mask for type of action required */
	char	*c_command;	/* Pointer to init command */
};

/*	Following are symbols for the various types of errors for	*/
/*	which "error_time" keeps timing entries.  MAX_E_TYPES is the	*/
/*	number of types currently being kept.				*/
#define	FULLTABLE	0
#define	BADLINE		1
#define	MAX_E_TYPES	2

static struct ERRORTIMES {
	long e_time;	/* Time of last message. */
	long e_max;	/* Amount of time to wait until next message. */
} err_times[MAX_E_TYPES] = { 0L,120L,0L,120L };

/****************************************
*	Useful file and device names.
***************************************/
char	*CONSOLE	=	"/dev/console";	/* virtual system console */
char	*SYSCON		=	"/dev/syscon"; /* link to "trusted console" */

#ifdef UDEBUG
char	*UTMP		=	"utmp";
char	*UTMP_LCK	=	"utmp.lck";
char	*WTMP		=	"wtmp";
char	*INITTAB	=	"inittab";
char	*DBG_FILE	=	"debug";
char	*IOCTLCONSOLE	=	".ioctl.console"; /* Last console modes */

#else

char	*UTMP	=	UTMP_FILE;	/* Snapshot record file */
char	UTMP_LCK[50];	/* Lock for snapshot record file */
char	*WTMP	=	WTMP_FILE;	/* Long term record file */
char	*INITTAB =	"/etc/inittab";	/* Script file for "init" */
char	*IOCTLCONSOLE	=	"/etc/.ioctl.console"; /* Last console modes */

#ifdef	DEBUGGER

char	*DBG_FILE	=	"/etc/debug";

#endif
#endif

char	*SU	=	"/bin/su";	/* Super-user for single user mode. */
char	*SH	=	"/bin/sh";	/* Standard Shell */

/*************************************
* The following structures contain a set
* of modes for /dev/console. The macros
* are defined in sys/termios.h.
*************************************/

/* #define	fioctl(p,sptr,cmd)	ioctl(fileno(p),sptr,cmd) */

struct	termios	dflt_termios = {
  BRKINT|ICRNL|IXON|IMAXBEL,                            /* input modes */
  OPOST|ONLCR|TAB3,			                /* output modes */
  B9600|CS8|CREAD,		      	                /* control modes */
  ISIG|ICANON|ECHO|ECHOE|ECHOK|ECHOCTL|ECHOKE|IEXTEN,   /* line disciplines */
  {CINTR,CQUIT,CERASE,CKILL,CEOF,CNUL,CNUL,CSTART,CSTOP} /* control chars */ 
};

struct termios	termios;



/*****************************************
* EXTERNAL VARIABLES
*****************************************/

int	n_prev[NSIG];	/* Number of times previously in state */
int	cur_state = -1;	/* Current state of "init" */
int	prev_state;	/* State "init" was in last time it woke */
int	new_state;	/* State user wants "init" to go to. */
int	prior_state;	/* temp var for runstate changes a-c */
int	op_modes = BOOT_MODES;	/* Current state of "init" */

/* A Flag And Its Masks */
int wakeup_flags = 0;
#define W_USRSIGNAL	01
#define W_CHILDEATH	02
#define W_POWERFAIL	04

unsigned int	spawncnt,syncnt,pausecnt;
int	rsflag;		/* Set if a respawn has taken place */
pid_t	own_pid;	/* This is the value of our own pid.
			* If the value is SPECIALPID, then we fork
			* to interact with outside world.  */
#ifdef	XDEBUG
char comment[120];
#endif

#define LOG TRUE
#define NOLOG FALSE
