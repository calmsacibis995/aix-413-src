static char sccsid[] = "@(#)60	1.4  src/tcpip/usr/lib/libisode/VPEPY.c, isodelib7, tcpip411, GOLD410 4/5/93 13:37:37";
/*
 * COMPONENT_NAME: (ISODELIB7) ISODE Libraries, Release 7
 *
 * FUNCTIONS: decode_UNIV_CharacterString decode_UNIV_EXTERNAL 
 *    decode_UNIV_GeneralString decode_UNIV_GeneralisedTime 
 *    decode_UNIV_GeneralizedTime decode_UNIV_GraphicString 
 *    decode_UNIV_IA5String decode_UNIV_ISO646String decode_UNIV_NumericString 
 *    decode_UNIV_ObjectDescriptor decode_UNIV_PrintableString 
 *    decode_UNIV_T61String decode_UNIV_TeletexString decode_UNIV_UTCTime 
 *    decode_UNIV_UniversalTime decode_UNIV_VideotexString 
 *    decode_UNIV_VisibleString encode_UNIV_CharacterString 
 *    encode_UNIV_EXTERNAL encode_UNIV_GeneralString 
 *    encode_UNIV_GeneralisedTime encode_UNIV_GeneralizedTime 
 *    encode_UNIV_GraphicString encode_UNIV_IA5String encode_UNIV_ISO646String 
 *    encode_UNIV_NumericString encode_UNIV_ObjectDescriptor 
 *    encode_UNIV_PrintableString encode_UNIV_T61String 
 *    encode_UNIV_TeletexString encode_UNIV_UTCTime encode_UNIV_UniversalTime 
 *    encode_UNIV_VideotexString encode_UNIV_VisibleString free_UNIV_EXTERNAL
 *
 * ORIGINS: 60
 *
 * FILE:	src/tcpip/usr/lib/libisode/VPEPY.c
 */

/* automatically generated by pepy 6.0 #86 (vikings.austin.ibm.com), do not edit! */

#include <isode/psap.h>

static char *pepyid = "pepy 6.0 #86 (vikings.austin.ibm.com) of Fri Mar 22 15:40:08 CST 1991";

#define	advise	PY_advise

void	advise ();

/* Generated from module UNIV */
# line 5 "UNIV-types.py"

#include <stdio.h>
#include <isode/pepy/UNIV-types.h>

#ifndef PEPYPARM
#define PEPYPARM char *
#endif /* PEPYPARM */
extern PEPYPARM NullParm;

/* ARGSUSED */

int	encode_UNIV_IA5String (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
struct type_UNIV_IA5String * parm;
{
    register struct qbuf *p0;

    p0 = parm ;
    if (p0 == ((struct qbuf *) 0)) {
        advise (NULLCP, "IA5String %s", PEPY_ERR_INIT_FAILED);
        return NOTOK;
    }
    if (((*pe) = qb2prim (p0, PE_CLASS_UNIV, 22)) == NULLPE) {
        advise (NULLCP, "IA5String: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "UNIV.IA5String");
#endif


    return OK;
}

/* ARGSUSED */

int	encode_UNIV_NumericString (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
struct type_UNIV_NumericString * parm;
{
    if (encode_UNIV_IA5String (pe, 0, len, buffer, parm ) == NOTOK)
        return NOTOK;
    (*pe) -> pe_class = PE_CLASS_UNIV;
    (*pe) -> pe_id = 18;

#ifdef DEBUG
    (void) testdebug ((*pe), "UNIV.NumericString");
#endif


    return OK;
}

/* ARGSUSED */

int	encode_UNIV_PrintableString (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
struct type_UNIV_PrintableString * parm;
{
    if (encode_UNIV_IA5String (pe, 0, len, buffer, parm ) == NOTOK)
        return NOTOK;
    (*pe) -> pe_class = PE_CLASS_UNIV;
    (*pe) -> pe_id = 19;

#ifdef DEBUG
    (void) testdebug ((*pe), "UNIV.PrintableString");
#endif


    return OK;
}

/* ARGSUSED */

int	encode_UNIV_T61String (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
struct type_UNIV_T61String * parm;
{
    register struct qbuf *p1;

    p1 = parm ;
    if (p1 == ((struct qbuf *) 0)) {
        advise (NULLCP, "T61String %s", PEPY_ERR_INIT_FAILED);
        return NOTOK;
    }
    if (((*pe) = qb2prim (p1, PE_CLASS_UNIV, 20)) == NULLPE) {
        advise (NULLCP, "T61String: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "UNIV.T61String");
#endif


    return OK;
}

/* ARGSUSED */

int	encode_UNIV_TeletexString (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
struct type_UNIV_TeletexString * parm;
{
    if (encode_UNIV_T61String (pe, 0, len, buffer, parm ) == NOTOK)
        return NOTOK;

#ifdef DEBUG
    (void) testdebug ((*pe), "UNIV.TeletexString");
#endif


    return OK;
}

/* ARGSUSED */

int	encode_UNIV_VideotexString (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
struct type_UNIV_VideotexString * parm;
{
    register struct qbuf *p2;

    p2 = parm ;
    if (p2 == ((struct qbuf *) 0)) {
        advise (NULLCP, "VideotexString %s", PEPY_ERR_INIT_FAILED);
        return NOTOK;
    }
    if (((*pe) = qb2prim (p2, PE_CLASS_UNIV, 21)) == NULLPE) {
        advise (NULLCP, "VideotexString: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "UNIV.VideotexString");
#endif


    return OK;
}

/* ARGSUSED */

int	encode_UNIV_GeneralizedTime (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
struct type_UNIV_GeneralizedTime * parm;
{
    if (encode_UNIV_VisibleString (pe, 0, len, buffer, parm ) == NOTOK)
        return NOTOK;
    (*pe) -> pe_class = PE_CLASS_UNIV;
    (*pe) -> pe_id = 24;

#ifdef DEBUG
    (void) testdebug ((*pe), "UNIV.GeneralizedTime");
#endif


    return OK;
}

/* ARGSUSED */

int	encode_UNIV_GeneralisedTime (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
struct type_UNIV_GeneralisedTime * parm;
{
    if (encode_UNIV_GeneralizedTime (pe, 0, len, buffer, parm ) == NOTOK)
        return NOTOK;

#ifdef DEBUG
    (void) testdebug ((*pe), "UNIV.GeneralisedTime");
#endif


    return OK;
}

/* ARGSUSED */

int	encode_UNIV_UTCTime (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
struct type_UNIV_UTCTime * parm;
{
    if (encode_UNIV_VisibleString (pe, 0, len, buffer, parm ) == NOTOK)
        return NOTOK;
    (*pe) -> pe_class = PE_CLASS_UNIV;
    (*pe) -> pe_id = 23;

#ifdef DEBUG
    (void) testdebug ((*pe), "UNIV.UTCTime");
#endif


    return OK;
}

/* ARGSUSED */

int	encode_UNIV_UniversalTime (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
struct type_UNIV_UniversalTime * parm;
{
    if (encode_UNIV_UTCTime (pe, 0, len, buffer, parm ) == NOTOK)
        return NOTOK;

#ifdef DEBUG
    (void) testdebug ((*pe), "UNIV.UniversalTime");
#endif


    return OK;
}

/* ARGSUSED */

int	encode_UNIV_GraphicString (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
struct type_UNIV_GraphicString * parm;
{
    register struct qbuf *p3;

    p3 = parm ;
    if (p3 == ((struct qbuf *) 0)) {
        advise (NULLCP, "GraphicString %s", PEPY_ERR_INIT_FAILED);
        return NOTOK;
    }
    if (((*pe) = qb2prim (p3, PE_CLASS_UNIV, 25)) == NULLPE) {
        advise (NULLCP, "GraphicString: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "UNIV.GraphicString");
#endif


    return OK;
}

/* ARGSUSED */

int	encode_UNIV_VisibleString (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
struct type_UNIV_VisibleString * parm;
{
    register struct qbuf *p4;

    p4 = parm ;
    if (p4 == ((struct qbuf *) 0)) {
        advise (NULLCP, "VisibleString %s", PEPY_ERR_INIT_FAILED);
        return NOTOK;
    }
    if (((*pe) = qb2prim (p4, PE_CLASS_UNIV, 26)) == NULLPE) {
        advise (NULLCP, "VisibleString: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "UNIV.VisibleString");
#endif


    return OK;
}

/* ARGSUSED */

int	encode_UNIV_ISO646String (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
struct type_UNIV_ISO646String * parm;
{
    if (encode_UNIV_VisibleString (pe, 0, len, buffer, parm ) == NOTOK)
        return NOTOK;

#ifdef DEBUG
    (void) testdebug ((*pe), "UNIV.ISO646String");
#endif


    return OK;
}

/* ARGSUSED */

int	encode_UNIV_GeneralString (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
struct type_UNIV_GeneralString * parm;
{
    register struct qbuf *p5;

    p5 = parm ;
    if (p5 == ((struct qbuf *) 0)) {
        advise (NULLCP, "GeneralString %s", PEPY_ERR_INIT_FAILED);
        return NOTOK;
    }
    if (((*pe) = qb2prim (p5, PE_CLASS_UNIV, 27)) == NULLPE) {
        advise (NULLCP, "GeneralString: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "UNIV.GeneralString");
#endif


    return OK;
}

/* ARGSUSED */

int	encode_UNIV_CharacterString (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
struct type_UNIV_CharacterString * parm;
{
    register struct qbuf *p6;

    p6 = parm ;
    if (p6 == ((struct qbuf *) 0)) {
        advise (NULLCP, "CharacterString %s", PEPY_ERR_INIT_FAILED);
        return NOTOK;
    }
    if (((*pe) = qb2prim (p6, PE_CLASS_UNIV, 28)) == NULLPE) {
        advise (NULLCP, "CharacterString: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }

#ifdef DEBUG
    (void) testdebug ((*pe), "UNIV.CharacterString");
#endif


    return OK;
}

/* ARGSUSED */

int	encode_UNIV_EXTERNAL (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
struct type_UNIV_EXTERNAL * parm;
{
# line 89 "UNIV-types.py"
    
	struct choice_UNIV_0 *choice_UNIV_0;
	char *bit_parm;
    
    PE	p7_z = NULLPE;
    register PE *p7 = &p7_z;

    if (((*pe) = pe_alloc (PE_CLASS_UNIV, PE_FORM_CONS, 8)) == NULLPE) {
        advise (NULLCP, "EXTERNAL: %s", PEPY_ERR_NOMEM);
        return NOTOK;
    }
    {
# line 96 "UNIV-types.py"

                choice_UNIV_0 = parm -> encoding;
            
    }
    (*p7) = NULLPE;

    if (parm -> direct__reference) {	/* direct-reference */
        register OID p8;

        p8 = parm -> direct__reference ;
        if (p8 == NULLOID) {
            advise (NULLCP, "direct-reference %s", PEPY_ERR_INIT_FAILED);
            return NOTOK;
        }
        if (((*p7) = obj2prim (p8, PE_CLASS_UNIV, PE_PRIM_OID)) == NULLPE) {
            advise (NULLCP, "direct-reference: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p7), "direct-reference");
#endif

    }

    if ((*p7) != NULLPE)
        if (seq_add ((*pe), (*p7), -1) == NOTOK) {
            advise (NULLCP, "EXTERNAL %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p7) = NULLPE;

    if (parm -> indirect__reference != 0) {	/* indirect-reference */
        register integer p9 = parm -> indirect__reference ;

        if (((*p7) = num2prim (p9, PE_CLASS_UNIV, PE_PRIM_INT)) == NULLPE) {
            advise (NULLCP, "indirect-reference: %s", PEPY_ERR_NOMEM);
            return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p7), "indirect-reference");
#endif

    }

    if ((*p7) != NULLPE)
        if (seq_add ((*pe), (*p7), -1) == NOTOK) {
            advise (NULLCP, "EXTERNAL %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p7) = NULLPE;

    if (parm -> data__value__descriptor) {	/* data-value-descriptor */
        if (encode_UNIV_ObjectDescriptor (p7, 0, NULL, NULLCP, parm -> data__value__descriptor ) == NOTOK)
            return NOTOK;

#ifdef DEBUG
        (void) testdebug ((*p7), "data-value-descriptor");
#endif

    }

    if ((*p7) != NULLPE)
        if (seq_add ((*pe), (*p7), -1) == NOTOK) {
            advise (NULLCP, "EXTERNAL %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }
    (*p7) = NULLPE;

    {	/* encoding */
        int	p10;

        switch (p10 = (choice_UNIV_0 -> offset)) {
            case 1:	/* single-ASN1-type */
                {
                    PE	p11 = choice_UNIV_0 -> un.single__ASN1__type ;

                    if (p11 == NULLPE) {
                        advise (NULLCP, "single-ASN1-type %s", PEPY_ERR_INIT_FAILED);
                        return NOTOK;
                    }
                    ((*p7) = p11) -> pe_refcnt++;

#ifdef DEBUG
                    (void) testdebug ((*p7), "single-ASN1-type");
#endif

                    {	/* single-ASN1-type TAG PUSHDOWN */
                        PE p12_z;
                        register PE *p12 = &p12_z;

                        if ((*p12 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 0)) == NULLPE) {
                            advise (NULLCP, "single-ASN1-type: %s", PEPY_ERR_NOMEM);
                            return NOTOK;
                        }
                        (*p12) -> pe_cons = (*p7);
                        (*p7) = *p12;
                    }
                }
                break;
            case 2:	/* octet-aligned */
                {
                    register struct qbuf *p13;

                    p13 = choice_UNIV_0 -> un.octet__aligned ;
                    if (p13 == ((struct qbuf *) 0)) {
                        advise (NULLCP, "octet-aligned %s", PEPY_ERR_INIT_FAILED);
                        return NOTOK;
                    }
                    if (((*p7) = qb2prim (p13, PE_CLASS_CONT, 1)) == NULLPE) {
                        advise (NULLCP, "octet-aligned: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }

#ifdef DEBUG
                    (void) testdebug ((*p7), "octet-aligned");
#endif

                }
                break;
            case 3:	/* arbitrary */
                {
                    PE	p14_z = NULLPE;
                    register PE *p14 = &p14_z;

                    char *p15;
                    int p16;
                    p15 = bit_parm = bitstr2strb (choice_UNIV_0 -> un.arbitrary, &len) ;
                    p16 =  len;
                    (*p14) = p15 ? strb2bitstr (p15, p16, PE_CLASS_CONT, 2) : NULLPE;
                    if ((*p14) == NULLPE) {
                        advise (NULLCP, "arbitrary %s", PEPY_ERR_INIT_FAILED);
                        return NOTOK;
                    }
                    if (((*p7) = bit2prim ((*p14))) == NULLPE) {
                        advise (NULLCP, "arbitrary: %s", PEPY_ERR_NOMEM);
                        return NOTOK;
                    }

#ifdef DEBUG
                    (void) testdebug ((*p7), "arbitrary");
#endif

                    {
# line 128 "UNIV-types.py"

                            free (bit_parm);
                        
                    }
                }
                break;

            default:
                advise (NULLCP, "encoding %s%d", PEPY_ERR_INVALID_CHOICE, 
                        p10);
                return NOTOK;
        }

#ifdef DEBUG
        (void) testdebug ((*p7), "encoding");
#endif

    }

    if ((*p7) != NULLPE)
        if (seq_add ((*pe), (*p7), -1) == NOTOK) {
            advise (NULLCP, "EXTERNAL %s%s", PEPY_ERR_BAD_SEQ,
                    pe_error ((*pe) -> pe_errno));
            return NOTOK;
        }

#ifdef DEBUG
    (void) testdebug ((*pe), "UNIV.EXTERNAL");
#endif


    return OK;
}

/* ARGSUSED */

int	encode_UNIV_ObjectDescriptor (pe, explicit, len, buffer, parm)
register PE     *pe;
int	explicit;
int	len;
char   *buffer;
struct type_UNIV_ObjectDescriptor * parm;
{
    if (encode_UNIV_GraphicString (pe, 0, len, buffer, parm ) == NOTOK)
        return NOTOK;
    (*pe) -> pe_class = PE_CLASS_UNIV;
    (*pe) -> pe_id = 7;

#ifdef DEBUG
    (void) testdebug ((*pe), "UNIV.ObjectDescriptor");
#endif


    return OK;
}

/* ARGSUSED */

int	decode_UNIV_IA5String (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct type_UNIV_IA5String ** parm;
{
    register struct qbuf *p17;

#ifdef DEBUG
    (void) testdebug (pe, "UNIV.IA5String");
#endif

    if (explicit
            && PE_ID (pe -> pe_class, pe -> pe_id)
                    != PE_ID (PE_CLASS_UNIV, 22)) {
        advise (NULLCP, "IA5String %s%s/0x%x", PEPY_ERR_BAD_CLASS,
                pe_classlist[pe -> pe_class], pe -> pe_id);
        return NOTOK;
    }
    if ((p17 = prim2qb (pe)) == (struct qbuf *)0) {
        advise (NULLCP, "IA5String %s%s", PEPY_ERR_BAD_OCTET,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    (*parm)  = p17;

    return OK;
}

/* ARGSUSED */

int	decode_UNIV_NumericString (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct type_UNIV_NumericString ** parm;
{
#ifdef DEBUG
    (void) testdebug (pe, "UNIV.NumericString");
#endif

    if (explicit
            && PE_ID (pe -> pe_class, pe -> pe_id)
                    != PE_ID (PE_CLASS_UNIV, 18)) {
        advise (NULLCP, "NumericString %s%s/0x%x", PEPY_ERR_BAD_CLASS,
                pe_classlist[pe -> pe_class], pe -> pe_id);
        return NOTOK;
    }
    if (decode_UNIV_IA5String (pe, 0, len, buffer, &((*parm))) == NOTOK)
        return NOTOK;

    return OK;
}

/* ARGSUSED */

int	decode_UNIV_PrintableString (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct type_UNIV_PrintableString ** parm;
{
#ifdef DEBUG
    (void) testdebug (pe, "UNIV.PrintableString");
#endif

    if (explicit
            && PE_ID (pe -> pe_class, pe -> pe_id)
                    != PE_ID (PE_CLASS_UNIV, 19)) {
        advise (NULLCP, "PrintableString %s%s/0x%x", PEPY_ERR_BAD_CLASS,
                pe_classlist[pe -> pe_class], pe -> pe_id);
        return NOTOK;
    }
    if (decode_UNIV_IA5String (pe, 0, len, buffer, &((*parm))) == NOTOK)
        return NOTOK;

    return OK;
}

/* ARGSUSED */

int	decode_UNIV_T61String (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct type_UNIV_T61String ** parm;
{
    register struct qbuf *p18;

#ifdef DEBUG
    (void) testdebug (pe, "UNIV.T61String");
#endif

    if (explicit
            && PE_ID (pe -> pe_class, pe -> pe_id)
                    != PE_ID (PE_CLASS_UNIV, 20)) {
        advise (NULLCP, "T61String %s%s/0x%x", PEPY_ERR_BAD_CLASS,
                pe_classlist[pe -> pe_class], pe -> pe_id);
        return NOTOK;
    }
    if ((p18 = prim2qb (pe)) == (struct qbuf *)0) {
        advise (NULLCP, "T61String %s%s", PEPY_ERR_BAD_OCTET,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    (*parm)  = p18;

    return OK;
}

/* ARGSUSED */

int	decode_UNIV_TeletexString (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct type_UNIV_TeletexString ** parm;
{
#ifdef DEBUG
    (void) testdebug (pe, "UNIV.TeletexString");
#endif

    if (decode_UNIV_T61String (pe, explicit, len, buffer, &((*parm))) == NOTOK)
        return NOTOK;

    return OK;
}

/* ARGSUSED */

int	decode_UNIV_VideotexString (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct type_UNIV_VideotexString ** parm;
{
    register struct qbuf *p19;

#ifdef DEBUG
    (void) testdebug (pe, "UNIV.VideotexString");
#endif

    if (explicit
            && PE_ID (pe -> pe_class, pe -> pe_id)
                    != PE_ID (PE_CLASS_UNIV, 21)) {
        advise (NULLCP, "VideotexString %s%s/0x%x", PEPY_ERR_BAD_CLASS,
                pe_classlist[pe -> pe_class], pe -> pe_id);
        return NOTOK;
    }
    if ((p19 = prim2qb (pe)) == (struct qbuf *)0) {
        advise (NULLCP, "VideotexString %s%s", PEPY_ERR_BAD_OCTET,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    (*parm)  = p19;

    return OK;
}

/* ARGSUSED */

int	decode_UNIV_GeneralizedTime (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct type_UNIV_GeneralizedTime ** parm;
{
#ifdef DEBUG
    (void) testdebug (pe, "UNIV.GeneralizedTime");
#endif

    if (explicit
            && PE_ID (pe -> pe_class, pe -> pe_id)
                    != PE_ID (PE_CLASS_UNIV, 24)) {
        advise (NULLCP, "GeneralizedTime %s%s/0x%x", PEPY_ERR_BAD_CLASS,
                pe_classlist[pe -> pe_class], pe -> pe_id);
        return NOTOK;
    }
    if (decode_UNIV_VisibleString (pe, 0, len, buffer, &((*parm))) == NOTOK)
        return NOTOK;

    return OK;
}

/* ARGSUSED */

int	decode_UNIV_GeneralisedTime (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct type_UNIV_GeneralisedTime ** parm;
{
#ifdef DEBUG
    (void) testdebug (pe, "UNIV.GeneralisedTime");
#endif

    if (decode_UNIV_GeneralizedTime (pe, explicit, len, buffer, &((*parm))) == NOTOK)
        return NOTOK;

    return OK;
}

/* ARGSUSED */

int	decode_UNIV_UTCTime (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct type_UNIV_UTCTime ** parm;
{
#ifdef DEBUG
    (void) testdebug (pe, "UNIV.UTCTime");
#endif

    if (explicit
            && PE_ID (pe -> pe_class, pe -> pe_id)
                    != PE_ID (PE_CLASS_UNIV, 23)) {
        advise (NULLCP, "UTCTime %s%s/0x%x", PEPY_ERR_BAD_CLASS,
                pe_classlist[pe -> pe_class], pe -> pe_id);
        return NOTOK;
    }
    if (decode_UNIV_VisibleString (pe, 0, len, buffer, &((*parm))) == NOTOK)
        return NOTOK;

    return OK;
}

/* ARGSUSED */

int	decode_UNIV_UniversalTime (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct type_UNIV_UniversalTime ** parm;
{
#ifdef DEBUG
    (void) testdebug (pe, "UNIV.UniversalTime");
#endif

    if (decode_UNIV_UTCTime (pe, explicit, len, buffer, &((*parm))) == NOTOK)
        return NOTOK;

    return OK;
}

/* ARGSUSED */

int	decode_UNIV_GraphicString (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct type_UNIV_GraphicString ** parm;
{
    register struct qbuf *p20;

#ifdef DEBUG
    (void) testdebug (pe, "UNIV.GraphicString");
#endif

    if (explicit
            && PE_ID (pe -> pe_class, pe -> pe_id)
                    != PE_ID (PE_CLASS_UNIV, 25)) {
        advise (NULLCP, "GraphicString %s%s/0x%x", PEPY_ERR_BAD_CLASS,
                pe_classlist[pe -> pe_class], pe -> pe_id);
        return NOTOK;
    }
    if ((p20 = prim2qb (pe)) == (struct qbuf *)0) {
        advise (NULLCP, "GraphicString %s%s", PEPY_ERR_BAD_OCTET,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    (*parm)  = p20;

    return OK;
}

/* ARGSUSED */

int	decode_UNIV_VisibleString (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct type_UNIV_VisibleString ** parm;
{
    register struct qbuf *p21;

#ifdef DEBUG
    (void) testdebug (pe, "UNIV.VisibleString");
#endif

    if (explicit
            && PE_ID (pe -> pe_class, pe -> pe_id)
                    != PE_ID (PE_CLASS_UNIV, 26)) {
        advise (NULLCP, "VisibleString %s%s/0x%x", PEPY_ERR_BAD_CLASS,
                pe_classlist[pe -> pe_class], pe -> pe_id);
        return NOTOK;
    }
    if ((p21 = prim2qb (pe)) == (struct qbuf *)0) {
        advise (NULLCP, "VisibleString %s%s", PEPY_ERR_BAD_OCTET,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    (*parm)  = p21;

    return OK;
}

/* ARGSUSED */

int	decode_UNIV_ISO646String (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct type_UNIV_ISO646String ** parm;
{
#ifdef DEBUG
    (void) testdebug (pe, "UNIV.ISO646String");
#endif

    if (decode_UNIV_VisibleString (pe, explicit, len, buffer, &((*parm))) == NOTOK)
        return NOTOK;

    return OK;
}

/* ARGSUSED */

int	decode_UNIV_GeneralString (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct type_UNIV_GeneralString ** parm;
{
    register struct qbuf *p22;

#ifdef DEBUG
    (void) testdebug (pe, "UNIV.GeneralString");
#endif

    if (explicit
            && PE_ID (pe -> pe_class, pe -> pe_id)
                    != PE_ID (PE_CLASS_UNIV, 27)) {
        advise (NULLCP, "GeneralString %s%s/0x%x", PEPY_ERR_BAD_CLASS,
                pe_classlist[pe -> pe_class], pe -> pe_id);
        return NOTOK;
    }
    if ((p22 = prim2qb (pe)) == (struct qbuf *)0) {
        advise (NULLCP, "GeneralString %s%s", PEPY_ERR_BAD_OCTET,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    (*parm)  = p22;

    return OK;
}

/* ARGSUSED */

int	decode_UNIV_CharacterString (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct type_UNIV_CharacterString ** parm;
{
    register struct qbuf *p23;

#ifdef DEBUG
    (void) testdebug (pe, "UNIV.CharacterString");
#endif

    if (explicit
            && PE_ID (pe -> pe_class, pe -> pe_id)
                    != PE_ID (PE_CLASS_UNIV, 28)) {
        advise (NULLCP, "CharacterString %s%s/0x%x", PEPY_ERR_BAD_CLASS,
                pe_classlist[pe -> pe_class], pe -> pe_id);
        return NOTOK;
    }
    if ((p23 = prim2qb (pe)) == (struct qbuf *)0) {
        advise (NULLCP, "CharacterString %s%s", PEPY_ERR_BAD_OCTET,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    (*parm)  = p23;

    return OK;
}

/* ARGSUSED */

int	decode_UNIV_EXTERNAL (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct type_UNIV_EXTERNAL ** parm;
{
# line 214 "UNIV-types.py"
    
	struct choice_UNIV_0 **choice_UNIV_0;
    
    register PE p24;

#ifdef DEBUG
    (void) testdebug (pe, "UNIV.EXTERNAL");
#endif

    if (explicit
            && PE_ID (pe -> pe_class, pe -> pe_id)
                    != PE_ID (PE_CLASS_UNIV, 8)) {
        advise (NULLCP, "EXTERNAL %s%s/0x%x", PEPY_ERR_BAD_CLASS,
                pe_classlist[pe -> pe_class], pe -> pe_id);
        return NOTOK;
    }
    {
# line 218 "UNIV-types.py"

        if ((*(parm) = (struct type_UNIV_EXTERNAL *)
                calloc (1, sizeof **(parm))) == ((struct type_UNIV_EXTERNAL *) 0)) {
            advise (NULLCP, "%s", PEPY_ERR_NOMEM);
            return NOTOK;
        }
        choice_UNIV_0 = &((*parm) -> encoding);
    
    }
    {
# line 228 "UNIV-types.py"

                (*parm) -> indirect__reference = 0;
                choice_UNIV_0 = &((*parm) -> encoding);
            
    }
    if ((p24 = prim2seq (pe)) == NULLPE) {
        advise (NULLCP, "EXTERNAL %s%s", PEPY_ERR_BAD_SEQ,
                pe_error (pe -> pe_errno));
        return NOTOK;
    }
    pe = p24;

    {
        register PE p25;

        if ((p25 = first_member (pe)) != NULLPE
                && PE_ID (p25 -> pe_class, p25 -> pe_id)
                        != PE_ID (PE_CLASS_UNIV, 6))
            p25 = NULLPE;
        if (p25 != NULLPE) {
            p24 = p25;

            {	/* direct-reference */
                register OID p26;

#ifdef DEBUG
                (void) testdebug (p25, "direct-reference");
#endif

                if (p25 -> pe_class != PE_CLASS_UNIV
                        || p25 -> pe_form != PE_FORM_PRIM
                        || p25 -> pe_id != PE_PRIM_OID) {
                    advise (NULLCP, "direct-reference bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p25 -> pe_class], p25 -> pe_form, p25 -> pe_id);
                    return NOTOK;
                }

                if ((p26 = prim2oid (p25)) == NULLOID) {
                    advise (NULLCP, "direct-reference %s%s", PEPY_ERR_BAD_OID,
                            pe_error (p25 -> pe_errno));
                    return NOTOK;
                }
                (*parm) -> direct__reference  = oid_cpy (p26);
            }
        }
    }

    {
        register PE p27;

        if ((p27 = (pe != p24 ? next_member (pe, p24) : first_member (pe))) 
                    != NULLPE
                && PE_ID (p27 -> pe_class, p27 -> pe_id)
                        != PE_ID (PE_CLASS_UNIV, 2))
            p27 = NULLPE;
        if (p27 != NULLPE) {
            p24 = p27;

            {	/* indirect-reference */
                register integer p28;

#ifdef DEBUG
                (void) testdebug (p27, "indirect-reference");
#endif

                if (p27 -> pe_class != PE_CLASS_UNIV
                        || p27 -> pe_form != PE_FORM_PRIM
                        || p27 -> pe_id != PE_PRIM_INT) {
                    advise (NULLCP, "indirect-reference bad class/form/id: %s/%d/0x%x",
                            pe_classlist[p27 -> pe_class], p27 -> pe_form, p27 -> pe_id);
                    return NOTOK;
                }

                {
# line 239 "UNIV-types.py"
 (*parm) -> indirect__reference = 0; 
                }
                if ((p28 = prim2num (p27)) == NOTOK
                        && p27 -> pe_errno != PE_ERR_NONE) {
                    advise (NULLCP, "indirect-reference %s%s", PEPY_ERR_BAD_INTEGER,
                            pe_error (p27 -> pe_errno));
                    return NOTOK;
                }
                (*parm) -> indirect__reference  = p28;
            }
        }
        else {
            /* set default here using yp -> yp_default */
        }

    }

    {
        register PE p29;

        if ((p29 = (pe != p24 ? next_member (pe, p24) : first_member (pe))) 
                    != NULLPE
                && PE_ID (p29 -> pe_class, p29 -> pe_id)
                        != PE_ID (PE_CLASS_UNIV, 7))
            p29 = NULLPE;
        if (p29 != NULLPE) {
            p24 = p29;

            {	/* data-value-descriptor */
#ifdef DEBUG
                (void) testdebug (p29, "data-value-descriptor");
#endif

                if (decode_UNIV_ObjectDescriptor (p29, 1, NULLIP, NULLVP, &((*parm) -> data__value__descriptor)) == NOTOK)
                    return NOTOK;
            }
        }
    }

    {
        register PE p30;

        if ((p30 = (pe != p24 ? next_member (pe, p24) : first_member (pe))) != NULLPE) {
            p24 = p30;

            {	/* encoding */
#ifdef DEBUG
                (void) testdebug (p30, "encoding");
#endif

                {
# line 251 "UNIV-types.py"

                        if ((*(choice_UNIV_0) = (struct choice_UNIV_0 *)
                                calloc (1, sizeof **(choice_UNIV_0))) == ((struct choice_UNIV_0 *) 0)) {
                            advise (NULLCP, "%s", PEPY_ERR_NOMEM);
                            return NOTOK;
                        }
                    
                }
                switch (PE_ID (p30 -> pe_class, p30 -> pe_id)) {
                    case PE_ID (PE_CLASS_CONT, 0):	/* single-ASN1-type */
                        {
                            register PE p31 = p30;

                            {	/* single-ASN1-type TAG PULLUP */
                                register PE p32;

                                if ((p32 = prim2set (p31)) == NULLPE) {
                                    advise (NULLCP, "single-ASN1-type %ssingle-ASN1-type: %s", PEPY_ERR_BAD,
                                            pe_error (p31 -> pe_errno));
                                    return NOTOK;
                                }
                                if (p32 -> pe_cardinal != 1) {
                                    advise (NULLCP, "single-ASN1-type %s single-ASN1-type: %d", PEPY_ERR_TOO_MANY_TAGGED,
                                            p32 -> pe_cardinal);
                                    return NOTOK;
                                }
                                p31 = first_member (p32);
                            }
                            {
#ifdef DEBUG
                                (void) testdebug (p31, "single-ASN1-type");
#endif

                                ((*choice_UNIV_0) -> un.single__ASN1__type  = p31) -> pe_refcnt++;
                                {
# line 262 "UNIV-types.py"
 (*(choice_UNIV_0)) -> offset = choice_UNIV_0_single__ASN1__type; 
                                }
                            }
                        }
                        break;
                    case PE_ID (PE_CLASS_CONT, 1):	/* octet-aligned */
                        {
                            register struct qbuf *p33;

#ifdef DEBUG
                            (void) testdebug (p30, "octet-aligned");
#endif

                            if ((p33 = prim2qb (p30)) == (struct qbuf *)0) {
                                advise (NULLCP, "octet-aligned %s%s", PEPY_ERR_BAD_OCTET,
                                        pe_error (p30 -> pe_errno));
                                return NOTOK;
                            }
                            (*choice_UNIV_0) -> un.octet__aligned  = p33;
                            {
# line 267 "UNIV-types.py"
 (*(choice_UNIV_0)) -> offset = choice_UNIV_0_octet__aligned; 
                            }
                        }
                        break;
                    case PE_ID (PE_CLASS_CONT, 2):	/* arbitrary */
                        {
                            register PE p34;

#ifdef DEBUG
                            (void) testdebug (p30, "arbitrary");
#endif

                            if ((p34 = prim2bit (p30)) == NULLPE) {
                                advise (NULLCP, "arbitrary %s%s", PEPY_ERR_BAD_BITS,
                                        pe_error (p30 -> pe_errno));
                                return NOTOK;
                            }
                            {
# line 271 "UNIV-types.py"

                            if (((*choice_UNIV_0) -> un.arbitrary = prim2bit (pe_cpy (p34))) == NULLPE) {
                                advise (NULLCP, "%s", PEPY_ERR_NOMEM);
                                return NOTOK;
                            }

                            (*(choice_UNIV_0)) -> offset = choice_UNIV_0_arbitrary;
                        
                            }
                        }
                        break;

                    default:
                        advise (NULLCP, "encoding %s%s/%d/0x%x", PEPY_ERR_UNKNOWN_CHOICE,
                                pe_classlist[p30 -> pe_class], p30 -> pe_form, p30 -> pe_id);
                        return NOTOK;
                }
            }
        }
        else {
            advise (NULLCP, "EXTERNAL %sencoding element", PEPY_ERR_MISSING);
            return NOTOK;
        }

    }


    if (pe -> pe_cardinal > 4) {
        advise (NULLCP, "EXTERNAL %s(4): %d", PEPY_ERR_TOO_MANY_ELEMENTS,
                pe -> pe_cardinal);
        return NOTOK;
    }

    return OK;
}

/* ARGSUSED */

int	decode_UNIV_ObjectDescriptor (pe, explicit, len, buffer, parm)
register PE	pe;
int	explicit;
int    *len;
char  **buffer;
struct type_UNIV_ObjectDescriptor ** parm;
{
#ifdef DEBUG
    (void) testdebug (pe, "UNIV.ObjectDescriptor");
#endif

    if (explicit
            && PE_ID (pe -> pe_class, pe -> pe_id)
                    != PE_ID (PE_CLASS_UNIV, 7)) {
        advise (NULLCP, "ObjectDescriptor %s%s/0x%x", PEPY_ERR_BAD_CLASS,
                pe_classlist[pe -> pe_class], pe -> pe_id);
        return NOTOK;
    }
    if (decode_UNIV_GraphicString (pe, 0, len, buffer, &((*parm))) == NOTOK)
        return NOTOK;

    return OK;
}
# line 289 "UNIV-types.py"


free_UNIV_EXTERNAL (arg)
struct type_UNIV_EXTERNAL *arg;
{
    struct type_UNIV_EXTERNAL *parm = arg;

    if (parm == NULL)
	return;

    if (parm -> direct__reference)
        oid_free (parm -> direct__reference),
            parm -> direct__reference = NULLOID;
    if (parm -> data__value__descriptor)
        free_UNIV_ObjectDescriptor (parm -> data__value__descriptor),
            parm -> data__value__descriptor = NULL;
    if (parm -> encoding) {
        struct choice_UNIV_0 *choice_UNIV_0 = parm -> encoding;

        switch (choice_UNIV_0 -> offset) {
            case choice_UNIV_0_single__ASN1__type:
                if (choice_UNIV_0 -> un.single__ASN1__type)
                    pe_free (choice_UNIV_0 -> un.single__ASN1__type),
                        choice_UNIV_0 -> un.single__ASN1__type = NULLPE;
                break;

            case choice_UNIV_0_octet__aligned:
                if (choice_UNIV_0 -> un.octet__aligned)
                    qb_free (choice_UNIV_0 -> un.octet__aligned),
                        choice_UNIV_0 -> un.octet__aligned = NULL;
                break;

            case choice_UNIV_0_arbitrary:
                if (choice_UNIV_0 -> un.arbitrary)
                    pe_free (choice_UNIV_0 -> un.arbitrary),
                        choice_UNIV_0 -> un.arbitrary = NULLPE;
                break;
        }

        if (parm -> encoding)
            free ((char *) parm -> encoding);
        parm -> encoding = NULL;
    }

    free ((char *) arg);
}

