static char sccsid[] = "@(#)16	1.9  src/tcpip/usr/sbin/snmpd/src.c, snmp, tcpip411, GOLD410 10/29/93 10:40:18";
/*
 * COMPONENT_NAME: (SNMPD) Simple Network Management Protocol Daemon
 *
 * FUNCTIONS: init_src(), under_src(), doit_src(), src_status(), 
 *            short_status(), domsg()
 *
 * ORIGINS: 27
 *
 * (C) COPYRIGHT International Business Machines Corp. 1991, 1993
 * All Rights Reserved
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 *
 * Licensed Material - Property of IBM
 *
 * FILE:	src/tcpip/usr/sbin/snmpd/src.c
 */

#ifdef SRC_SUPPORT

# include <isode/snmp/io.h>
# include "snmpd.h"
# include <sys/types.h>
# include <sys/socket.h>
# include <sys/stat.h>
# include <signal.h>
# include <spc.h>
# include "view.h"
# include "smux_g.h"

#ifdef DEBUG
#if	defined (AIX) && defined (RT)
#include  <sys/syslog.h>
#else
#include  <syslog.h>
#endif
#endif

extern char  *Myname;

extern void snmpd_exit ();
extern void start_log (), stop_log ();
extern int intsig();

extern struct logging    *logging;	/* defined in logging.c */
extern int maxopsize;
extern int stimeout;
extern int smuxtimeout;

void  src_status ();
void  short_status ();

int cont;
static struct srcreq srcmsg;
struct srchdr *srcrrqs();
struct srchdr *srchdr;
static char progname[] = "snmpd";	/* name of src object */
static int domsg();


/*
 * NAME: init_src ()
 *
 * FUNCTION: Checks if the agent is invoked by src. If so, sets up the 
 *           fdinfo for src.
 *
 * RETURNS:  NOTOK (not under SRC control)
 *     	     OK    (under SRC control) 
 */

int
init_src() 
{
    struct fdinfo *fi;

    /* 
     * Check to see if we were invoked by src.
     */

    if (!under_src ())
	return NOTOK;

    /* 
     * src_invoked, set up fdinfo for src.
     */

    if ((fi = addfd()) == NULL) {
	adios (MSGSTR(MS_SRC, SRC_11, "cannot add fd"));
    }
    fi -> fi_flags = FI_SRC;
    fi -> fi_fd = 0;
    return OK;
}

/*
 * NAME: under_src ()
 * 
 * FUNCTION: Determines if snmpd is invoked under SRC control.
 *
 * RETURNS:  TRUE     if invoked via SRC
 *           FALSE    otherwise
 */
int
under_src ()
{
    int err;
    struct sockaddr saddr;

    /* 
     * Check to see if stdin is a socket.  If so, it means that we were
     * invoked by src.						
     */

    err = sizeof (saddr);
    if (getsockname (0, &saddr, &err) < 0) 
	return FALSE;		

    return TRUE;
}


/*
 *  NAME: src_status ()
 *
 *  FUNCTION:
 *   Prints the long form of the snmpd subsystem status. The long status 
 *   includes the logging and tracing information, community and view status, 
 *   and smux client information defined in the snmpd config file. Finnally
 *   the short status is generated by SRC daemon.
 */
static void
src_status ()
{
    struct statrep *status;
    short statsize, srcreplen;
    int continued, rc;
    register struct community *c;
    register struct trap *t;
    register struct view *v;
    register struct subtree *vs, *x;
    register struct smuxClient *s;
    int first;
    int i;
    char permission[20], addr[80];

    srchdr = srcrrqs (&srcmsg);

    /* 
     * Check the caller's privilege. 
     */
    if (srchdr -> retaddr.sun_family == AF_UNIX) {
	/*
	 * Local host. Only root has the access to long status.
	 */

        struct stat statbuf;

        if (stat (srchdr -> retaddr.sun_path, &statbuf) == 1) {
       	    advise (SLOG_EXCEPTIONS, MSGSTR(MS_SRC, SRC_1,
		    "src_status: cannot execute stat()"));
            domsg (SRC_SUBMSG, MSGSTR(MS_SRC, SRC_14, 
		"\nError: cannot determine the user.\n\n"), 
		sizeof (struct srcrep));
            cont = END;
            domsg (SRC_OK, "", sizeof (struct srcrep));
	    return;
        }
        if (statbuf.st_uid != 0){
	    advise (SLOG_EXCEPTIONS, MSGSTR(MS_SRC, SRC_2,
		"not root user, cannot access long status"));
            domsg (SRC_SUBMSG, MSGSTR(MS_SRC, SRC_3,
		  "\nNot root user, cannot access long status.\n\n"), 
	          sizeof (struct srcrep));
	    short_status ();
            cont = END;
            domsg (SRC_OK, "", sizeof (struct srcrep));
	    return;
        }
    }
    else 
	/*
	 * Remote host. Root can access long status now for development
	 * purpose. May be more restrictive later. 
	 */
	if (ntohs (((struct sockaddr_in *)&(srchdr -> retaddr))->sin_port) 
		> 1023) {
	    advise (SLOG_EXCEPTIONS, MSGSTR(MS_SRC, SRC_2,
		"not root user, cannot access long status"));
            domsg (SRC_SUBMSG, MSGSTR(MS_SRC, SRC_3,
		  "\nNot root user, cannot access long status.\n\n"), 
	          sizeof (struct srcrep));
	    short_status ();
            cont = END;
            domsg (SRC_OK, "", sizeof (struct srcrep));
	    return;
	}

    cont = STATCONTINUED;
    srcreplen = sizeof (struct srchdr);
    statsize = sizeof (struct srchdr) + sizeof (struct statcode) * 10;
    status = (struct statrep *) malloc (statsize);
    if (status == NULL) {
        domsg (SRC_SUBMSG, MSGSTR(MS_GENERAL, GENERA_2, "No memory."), 
		sizeof (struct srcrep));
	adios (MSGSTR(MS_GENERAL, GENERA_1, "%s: Out of Memory"), "src_status");
    }
    memset (status, '\0', statsize);

    /*
     * Print the log file name and tracing status.
     * Structure limitations spelled out in spc.h:
     *   char  statcode[i].objname[30]
     *   char  statcode[i].objtext[64]
     * Remember that each string requires a '\0'.
     */

    sprintf (status->statcode[0].objname, " %-16s", "Logfile:"); 
    sprintf (status->statcode[0].objtext, "%.64s", 
	    logging -> l_filename == NULL ? "" : logging -> l_filename);
    srcreplen += sizeof (struct statcode);

    sprintf (status->statcode[1].objname, " %-16s", "Tracing:"); 
    sprintf (status->statcode[1].objtext, "%-24s %-24s", 
	    logging -> l_enabled == OK ? "ENABLED" : "DISABLED",
	    logging -> l_logfp == NULL ? "NOT ACTIVE" : "ACTIVE");
    srcreplen += sizeof (struct statcode);
    sprintf (status->statcode[2].objname, " %-16s", "Debug level:"); 
    sprintf (status->statcode[2].objtext, "%d", logging -> l_level);
    srcreplen += sizeof (struct statcode);
    sprintf (status->statcode[3].objname, " %-16s", "Max Packet Size:"); 
    sprintf (status->statcode[3].objtext, "%d", maxopsize);
    srcreplen += sizeof (struct statcode);
    sprintf (status->statcode[4].objname, " %-16s", "Query Timeout:"); 
    sprintf (status->statcode[4].objtext, "%d", stimeout);
    srcreplen += sizeof (struct statcode);
    sprintf (status->statcode[5].objname, " %-16s", "SMUX Timeout:"); 
    sprintf (status->statcode[5].objtext, "%d", smuxtimeout);
    srcreplen += sizeof (struct statcode);
    srcreplen += sizeof (struct statcode);
    srcsrpy (srchdr, status, srcreplen, cont);
 
    /*
     * Print the community name, address, netmask, permission, and view
     * for each node in the community queue. 
     */
    
    if (CHead -> c_forw == CHead) {
        memset (status, '\0', srcreplen);
        srcreplen = sizeof (struct srchdr);
        sprintf (status->statcode[0].objname, "%s", MSGSTR(MS_SRC, SRC_20,
		"No COMMUNITY configured")); 
        srcreplen += sizeof (struct statcode);
        srcreplen += sizeof (struct statcode);
	srcsrpy (srchdr, status, srcreplen, cont);
    }

    for (c = CHead -> c_forw; c != CHead; c = c -> c_forw) {
        memset (status, '\0', srcreplen);
        srcreplen = sizeof (struct srchdr);
        sprintf (status->statcode[0].objname, "%-16s", "COMMUNITY:"); 
        sprintf (status->statcode[0].objtext, "%.64s", c -> c_name); 
        srcreplen += sizeof (struct statcode);

        strcpy (addr, inet_ntoa (c -> c_sin.sin_addr.s_addr));
        sprintf (status->statcode[1].objname, "%-16s", "  ADDRESS:"); 
        sprintf (status->statcode[1].objtext, "%.64s", addr);
        srcreplen += sizeof (struct statcode);

        sprintf (status->statcode[2].objname, "%-16s", "  NETMASK:"); 
        sprintf (status->statcode[2].objtext, "%.64s",
                 inet_ntoa (c -> c_netmask.sin_addr.s_addr));
        srcreplen += sizeof (struct statcode);

        switch (c -> c_permission) {
            case OT_RDONLY:
                strcpy (permission, "readOnly");
                break;
            case OT_RDWRITE:
                strcpy (permission, "readWrite");
                break;
            case OT_WRONLY:
                strcpy (permission, "writeOnly");
                break;
            case OT_NONE:
                strcpy (permission, "none");
                break;
            default:
                strcpy (permission, "");
                break;
	}  
        sprintf (status->statcode[3].objname, "%-16s", "  PERMISSION:"); 
	sprintf (status->statcode[3].objtext, "%.64s", permission);
	srcreplen += sizeof (struct statcode);

	sprintf (status->statcode[4].objname, "%-16s", "  VIEW:"); 
	sprintf (status->statcode[4].objtext, "%.64s", 
	        sprintoid (c -> c_vu));
	srcreplen += sizeof (struct statcode);

	/* 
	 * Add a blank line to the status and print all.
	 */
	srcreplen += sizeof (struct statcode);
	srcsrpy (srchdr, status, srcreplen, cont);
    }

    /*
     * Print the view information.  Print 10 subtree names at a time.
     */

    for (v = VHead -> v_forw; v != VHead; v = v -> v_forw) {
        memset (status, '\0', srcreplen);
        srcreplen = sizeof (struct srchdr);
	sprintf (status->statcode[0].objname, "%-16s", "VIEW NAME:"); 
	sprintf (status->statcode[0].objtext, "%.64s", 
	        sprintoid (v -> v_name));
	srcreplen += sizeof (struct statcode);

	first = TRUE;
        vs = &v -> v_subtree;
	x = vs -> s_forw;
	if (x == vs) {
	    sprintf (status->statcode[1].objname, "%-16s", "  SUBTREE(S):");
            sprintf (status->statcode[1].objtext, "%s", "iso");
       	    srcreplen += sizeof (struct statcode);
       	    srcreplen += sizeof (struct statcode);
	}
        srcsrpy (srchdr, status, srcreplen, cont);

        while (x != vs) {
            memset (status, '\0', srcreplen);
            srcreplen = sizeof (struct srchdr);
	    for (i = 0; i < 10, x != vs; i++, x = x -> s_forw) {
		if ((i == 0) && (first))
        	    sprintf (status->statcode[i].objname, "%-16s", 
			     "  SUBTREE(S):");
		else
        	    sprintf (status->statcode[i].objname, "%-16s", "");
        	sprintf (status->statcode[i].objtext, "%.64s", x -> s_text);
        	srcreplen += sizeof (struct statcode);
		first = FALSE;
	    }
	    if (x == vs)
       	        srcreplen += sizeof (struct statcode);
            srcsrpy (srchdr, status, srcreplen, cont);
    	}
    }

    /*
     * Print the header for trap information.
     */

    t = UHead -> t_forw;
    if (t == UHead) {
        memset (status, '\0', srcreplen);
        srcreplen = sizeof (struct srchdr);
        sprintf (status->statcode[0].objname, "%s", MSGSTR(MS_SRC, SRC_21,
		"No TRAP configured")); 
        srcreplen += sizeof (struct statcode);
        srcreplen += sizeof (struct statcode);
	srcsrpy (srchdr, status, srcreplen, cont);
    }
    else {
        memset (status, '\0', srcreplen);
        sprintf (status->statcode[0].objname, "%-16s", "TRAP DESTINATION"); 
        sprintf (status->statcode[1].objname, "%-29s", "COMMUNITY"); 
        sprintf (status->statcode[1].objtext, "%s", "ADDRESS");
        srcreplen = sizeof (struct srchdr) + sizeof (struct statcode) * 2;
        srcsrpy (srchdr, status, srcreplen, cont);
    }

    /*
     * Print the trap destinations community and address from the
     * trap queue. If there are more than 10 nodes in trap queue,
     * prints 10 at a time.
     */

    while (t != UHead) {
        memset (status, '\0', srcreplen);
        srcreplen = sizeof (struct srchdr);
	for (i = 0; i < 10, t != UHead; i++, t = t -> t_forw) {
	    sprintf (status->statcode[i].objname, "%-29s", t -> t_name); 
	    sprintf (status->statcode[i].objtext, "%.64s",
	    	    inet_ntoa (((struct sockaddr_in *)
		    &t -> t_view -> v_sa) -> sin_addr.s_addr));
	    srcreplen += sizeof (struct statcode);
	}
	if (t == UHead)
	    srcreplen += sizeof (struct statcode);
	srcsrpy (srchdr, status, srcreplen, cont);
    }

    /*
     * Print the header for smux information.
     */

    if (SHead -> sc_forw == SHead) {
        memset (status, '\0', srcreplen);
        srcreplen = sizeof (struct srchdr);
        sprintf (status->statcode[0].objname, "%s", MSGSTR(MS_SRC, SRC_22,
		"No SMUX configured")); 
        srcreplen += sizeof (struct statcode);
        srcreplen += sizeof (struct statcode);
	srcsrpy (srchdr, status, srcreplen, cont);
    }

    /*
     * Print the smux client identifier, password, address, and netmask from 
     * the smux queue.
     */

    for (s = SHead -> sc_forw; s != SHead; s = s -> sc_forw) {
        memset (status, '\0', srcreplen);
        srcreplen = sizeof (struct srchdr);

        sprintf (status->statcode[0].objname, "%-16s", "SMUX CLIENT:"); 
	sprintf (status->statcode[0].objtext, "%.64s", sprintoid (s -> sc_id));
	srcreplen += sizeof (struct statcode);

        sprintf (status->statcode[1].objname, "%-16s", "  PASSWORD:"); 
        sprintf (status->statcode[1].objtext, "%.64s", s -> sc_password); 
	srcreplen += sizeof (struct statcode);

        strcpy (addr, inet_ntoa (s -> sc_sin.sin_addr.s_addr));
        sprintf (status->statcode[2].objname, "%-16s", "  ADDRESS:"); 
        sprintf (status->statcode[2].objtext, "%.64s", addr);
        srcreplen += sizeof (struct statcode);

        sprintf (status->statcode[3].objname, "%-16s", "  NETMASK:"); 
        sprintf (status->statcode[3].objtext, "%.64s",
                 inet_ntoa (s -> sc_netmask.sin_addr.s_addr));
        srcreplen += sizeof (struct statcode);

	/* 
	 * Add a blank line to the status and print all.
	 */
	srcreplen += sizeof (struct statcode);
	srcsrpy (srchdr, status, srcreplen, cont);
    }

    if (status)
	free (status);

    short_status ();
}


/*
 * NAME: short_status ()
 *
 * FUNCTION: Gets the short status from the SRC daemon.
 */
void
short_status ()
{
    struct statrep  *status;
    short  statsize;
    short  srcreplen;
    int    continued, rc;

    srcreplen = sizeof (struct srchdr);
    statsize = sizeof (struct srchdr) + sizeof (struct statcode);
    if ((status = (struct statrep *) malloc (statsize)) == NULL) {
        domsg (SRC_SUBMSG, MSGSTR(MS_GENERAL, GENERA_2, "No memory."), 
		sizeof (struct srcrep));
	adios (MSGSTR(MS_GENERAL, GENERA_1, "%s: Out of Memory"), 
		"short_status");
    }
    memset (status, '\0', statsize);

    continued = NEWREQUEST;
    do {
        memset (status, '\0', srcreplen);
	rc = srcstat ("", "", getpid(), &statsize, status, &continued);
        srcsrpy (srchdr, status, statsize, continued);
    } while (rc >= 0 && continued != END);

    free (status);
}


/*
 * NAME: doit_src ()
 *
 * FUNCTION:
 *   Receives the src message, prepares the appropriate reply message
 *   for the action specified. 
 *
 * RETURNS: NOTOK (failure)
 *          OK    (success) 
 */

int   
doit_src ()
{
    int    rc;
    char  *msg_text; 

    /* 
     * gets the src msg 
     */
    do {
        rc = recvfrom (0, &srcmsg, sizeof (srcmsg), 0, 0, 0);
    } while ( rc == -1 && errno == EINTR);

    if (rc < 0)
	adios (MSGSTR(MS_SRC, SRC_12, "doit_src: recvfrom"));

    cont = CONTINUED;
    switch (srcmsg.subreq.action) {
	case START :  /* start a subserver */
	    /* subserver is not supported - this is never executed */
	    domsg (SRC_SUBMSG, MSGSTR(MS_SRC, SRC_15, 
		"\nStart subserver: not supported.\n\n"), 
		sizeof (struct srcrep));
    	    cont = END;
	    domsg (SRC_OK, "", sizeof (struct srcrep));
	    return OK;

	case STOP :  /* stop a subsystem or a subserver */
	    if (srcmsg.subreq.object == SUBSYSTEM) {
		advise (SLOG_NOTICE, MSGSTR(MS_SRC, SRC_4, "stopsrc issued"));
    		cont = END;
		domsg (SRC_OK, "", sizeof (struct srcrep));
		if (srcmsg.subreq.parm1 != FORCED){ /* force subsystem to stop*/
		    /* clean up and exit right away */
		    snmpd_exit (0, TRUE);
		}
		/* 
		 * Normal stop: ignore all new requests, process all out
		 * standing requests, wait for all subservers to finish,
		 * and then exit. 
		 */
		snmpd_exit (0, TRUE); 
	    } else {  /* stop a subserver, not supported */
		domsg (SRC_SUBMSG, MSGSTR(MS_SRC, SRC_16, 
		    "\nStop subserver: not supported.\n\n"), 
		    sizeof (struct srcrep));
    		cont = END;
		domsg (SRC_OK, "", sizeof (struct srcrep));
	        return OK;
	    }	

	case STATUS :/* query the long status of a subserver or a subsystem */
	    if (srcmsg.subreq.object == SUBSYSTEM) {
		src_status ();
	    } else { /* subserver, not supported */
		domsg (SRC_SUBMSG, MSGSTR(MS_LOG, SRC_17,
		    "\nStatus of subserver: not supported.\n\n"), 
		    sizeof (struct srcrep));
    		cont = END;
		domsg (SRC_OK, "", sizeof (struct srcrep));
	    }	
	    return OK;

	case TRACE :  /* turn on or off the trace of a subsystem */
	    if (srcmsg.subreq.object == SUBSYSTEM) {
		if (srcmsg.subreq.parm2) {
		    if ((logging -> l_enabled == OK) &&
			(logging -> l_filename != NULLCP)) {
			advise (SLOG_NOTICE, MSGSTR(MS_SRC, SRC_5,
			        "traceson: logging is already enabled"));
	                domsg (SRC_SUBMSG, MSGSTR(MS_SRC, SRC_6,
			      "\ntraceson: logging is already enabled.\n\n"), 
			      sizeof (struct srcrep)); 
		    }
		    else {
			if (logging -> l_filename == NULLCP) {
			    if ((msg_text = (char *)malloc(strlen(Myname) + 35))
				    == NULL) {
				adios (MSGSTR(MS_GENERAL, GENERA_1, 
					"%s: Out of Memory"), "doit_src");
			    }
			    sprintf (msg_text, "\n%s %s", Myname, 
					MSGSTR(MS_SRC, SRC_7, 
					"is not configured for logging.\n\n"));
	                    domsg (SRC_SUBMSG, msg_text, sizeof(struct srcrep));
			    free (msg_text);
			}
			else
	                    domsg (SRC_SUBMSG, MSGSTR(MS_SRC, SRC_13,
				"\nStart trace.\n\n"), 
			        sizeof (struct srcrep)); 
		        start_log (TRUE);
		    }
		}
		else {
		    if (logging -> l_enabled == NOTOK) {
			if (logging -> l_filename == NULLCP) {
			    if ((msg_text = (char *)malloc(strlen(Myname) + 35))
				    == NULL) {
				adios (MSGSTR(MS_GENERAL, GENERA_1, 
					"%s: Out of Memory"), "doit_src");
			    }
			    sprintf (msg_text, "\n%s %s", Myname, 
				    MSGSTR(MS_SRC, SRC_7,
					"is not configured for logging.\n\n"));
	                    domsg (SRC_SUBMSG, msg_text, 
				   sizeof (struct srcrep)); 
			    free (msg_text);
			}
			else {
	                    domsg (SRC_SUBMSG, MSGSTR(MS_SRC, SRC_8,
			   "\ntracesoff: logging is already disabled.\n\n"), 
			           sizeof (struct srcrep)); 
			    advise (SLOG_NOTICE, MSGSTR(MS_SRC, SRC_9,
			           "tracesoff: logging is already disabled"));
			}
		    }
		    else {
	                domsg (SRC_SUBMSG, MSGSTR(MS_SRC, SRC_10,
				"\nStop trace.\n\n"), 
			    sizeof (struct srcrep)); 
			stop_log (logging -> l_filename, TRUE);
		    }
		}
    		cont = END;
	        domsg (SRC_OK, "", sizeof (struct srcrep)); /* confirm ok */
		/* call func to turn on or off the subsystem */
	    } else { /* trace subserver, not supported */
		domsg (SRC_SUBMSG, MSGSTR(MS_SRC, SRC_18,
		    "\nTrace subserver: not supported.\n\n"), 
		    sizeof (struct srcrep));
    		cont = END;
	        domsg (SRC_OK, "", sizeof (struct srcrep)); 
	    }	 
	    return OK;

	case REFRESH :  /* re-read config file */
	    /* call function to read config file */
	    refresh ();
            cont = END;
	    domsg (SRC_OK, "", sizeof (struct srcrep));  /* confirm ok */
	    return OK;
	default :  /* illegal cmd */
            domsg (SRC_SUBMSG, MSGSTR(MS_SRC, SRC_19, "\nIllegal command.\n\n"),
		   sizeof (struct srcrep));
            cont = END;
	    domsg (SRC_SUBICMD, "", sizeof (struct srcrep));
	    return NOTOK;
    }
}
 
/*
 * NAME: domsg ()
 *
 * FUNCTION: Sends the reply message to src daemon.    
 */

static int 
domsg (msgno, txt, len)
int msgno;
char *txt;
int len;
{
    struct srcrep reply;

    reply.svrreply.rtncode = msgno;
    strcpy (reply.svrreply.objname, progname);
    strcpy (reply.svrreply.rtnmsg, txt);
    srchdr = srcrrqs (&srcmsg);
    srcsrpy (srchdr, &reply, len, cont);
}

#endif  /* SRC_SUPPORT */
