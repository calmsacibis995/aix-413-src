static char sccsid[] = "@(#)25	1.8  src/tcpip/usr/sbin/oiddump/oiddump.c, snmp, tcpip411, GOLD410 11/10/93 11:11:44";
/*
 * COMPONENT_NAME: (SNMP) Simple Network Management Protocol Daemon
 *
 * FUNCTIONS: main(), oid_dump(), v_access(), v_status(), object_dump()
 *
 * ORIGINS: 27
 *
 * (C) COPYRIGHT International Business Machines Corp. 1991, 1993
 * All Rights Reserved
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 * Licensed Material - Property of IBM
 *
 * FILE:	src/tcpip/usr/sbin/snmpinfo/oiddump.c
 */


/*
 * just a silly program to check-out our internal mib database.
 * Helps to correct problems as we deal with other vendors
 * enterprise specific mibs.
 *
 * Also used to generate 'importobjects' format c-code.
 */

#include <stdio.h>
#include <isode/snmp/objects.h>
#include <nl_types.h>

extern void advise ();
extern OT get_anchor();		/* from objects.c */

extern char *optarg;
extern int debug;

static char *objfile;
char *Myname;

main(argc, argv)
int argc;
char *argv[];
{
    int i, agent = 0, dump = 0;

    Myname = (Myname = rindex (*argv, '/')) == NULL ? *argv : Myname+1;
    o_advise = (IFP) advise;    /* for libsnmp.a */
    while ((i = getopt (argc, argv, "-AD:o:d")) != EOF) {
	switch (i) {
	    case 'A':	/* dump for agent */
		agent++;
		break;
	    case 'o':
		if (readobjects (objfile = optarg) == -1) 
		    fprintf (stderr, "READOBJECTS failed: %s\n", PY_pepy);
		break;
	    case 'D':
		dump = atoi (optarg);
		fprintf (stderr, "dump = %d\n", dump);
		break;
	    case 'd':
		debug++;
		break;
	    case '?':
		fprintf (stderr, "Usage: %s [-A] [-d] [-D 0-5] -o defs_file [-o defs_file] ...\n", argv[0]);
		exit (1);
	}
    }
    if (dump) {
	switch (dump) {
	    case 0:
		printf ("oid_dump (0)\n");
		oid_dump (0);
		break;
	    case 1:
		printf ("dump_objects_by_text ()\n");
		dump_objects_by_text ();
		break;
	    case 2:
		printf ("dump_objects_by_tree ()\n");
		dump_objects_by_tree ();
		break;
	    case 3:
		printf ("dump_objects_by_xxx ()\n");
		dump_objects_by_xxx ();
		break;
	    case 4:
		printf ("oid_dump (1)\n");
		oid_dump (1);
		break;
	    case 5:
		printf ("oid_dump (2)\n");
		oid_dump (2);
		break;
	}
    }
    else
	agent ? object_dump (stdout) : oid_dump (0);
    exit (0);
}

/*
 *	Useful for debugging problems in your defs file
 */
oid_dump (style)
int style;
{
    register OT ot;
    int l1, l2, l3;
    int tl1, tl2, tl3;

    if (!style) {
	l1 = l2 = l3 = 0;
	for (ot = get_anchor(); ot; ot = ot -> ot_next) {
	    tl1 = strlen (ot -> ot_text);
	    tl2 = strlen (ot -> ot_id);
	    tl3 = strlen (sprintoid (ot -> ot_name));
	    l1 = tl1 > l1 ? tl1 : l1;
	    l2 = tl2 > l2 ? tl2 : l2;
	    l3 = tl3 > l3 ? tl3 : l3;
	}
	l1++; l2++; l3++;
    }
    for (ot = get_anchor(); ot; ot = ot -> ot_next) 
	switch (style) {
	    case 0:
		printf ("%-*.*s%-*.*s%-*.*s\n", 
			l1, l1, ot -> ot_text, 
			l2, l2, ot -> ot_id, 
			l3, l3, sprintoid (ot -> ot_name));
		break;
	    case 1:
		printf ("%s %s %s %s\n", 
			ot -> ot_text, ot -> ot_id, sprintoid (ot -> ot_name),
			ot -> ot_ltext);
		break;
	    case 2:
		printf ("%s\n", ot -> ot_ltext);
		break;
	}
    printf ("///////\n");
}

/***** support for importobjects() c-code creation *****/

/* be nice.  Turn access and syntax into #defines that humans can read */
static char *
v_access (access)
int	access;
{
    if (!access)
	return ("OT_NONE");
    if ((access & OT_RDWRITE) == OT_RDWRITE)
	return ("OT_RDWRITE");
    if (access & OT_WRONLY)
	return ("OT_WRONLY");
    return ("OT_RDONLY");
}

static char *
v_status (access)
int	access;
{
    if (!access)
	return ("OT_NONE");	/* should be OBSOLETE... but doesn't apply.. */
    if ((access & OT_DEPRECATED) == OT_DEPRECATED)
	return ("OT_DEPRECATED");
    if (access & OT_OPTIONAL)
	return ("OT_OPTIONAL");
    return ("OT_MANDATORY");
}

extern object_syntax syntaxes[];		/* from syntax.c */
extern OS synlast;		 		/* from syntax.c */

static void
dump_syntax_table (cfp)
FILE *cfp;
{
    register OS	    os;
    int	i = 0;

    fprintf (cfp, "/* a mapping to syntax name */\n\n");
    fprintf (cfp, "static char *syntax[] = {\n");
    fprintf (cfp, "#define type_SYNTAX_NULLOS\t%d\n\tNULLCP,\n", i++);
    for (os = syntaxes; os < synlast; os++, i++)
	fprintf (cfp, "#define type_SYNTAX_%s\t%d\n\t\"%s\",\n",
		os -> os_name, i, os -> os_name);
    fprintf (cfp, "};\n\n");
}


/*
 *	Generates static structures (to avoid name conflicts) plus
 *	an init stub (init_objects).
 */
int
object_dump (cfp)
FILE *cfp;
{
    register OT ot;

    fprintf (cfp, "/* automatically generated by %s, do not edit! */\n", 
	    Myname);
    fprintf (cfp, "\n#ifndef PEPYPATH\n#include <isode/snmp/objects.h>\n#else\n#include \"objects.h\"\n#endif\n\n");
    fprintf (cfp, "#ifndef NULL\n#define NULL 0\n#endif\n\n");

    /* Dump the syntax table. */ 
    dump_syntax_table (cfp);

    /* minimal object table */
    fprintf (cfp, "static struct import_object_type table_MIB_iobjects[] = {\n");
    for (ot = get_anchor(); ot; ot = ot -> ot_next) 
	fprintf (cfp, "\t{ \"%s\", \"%s\",\n\t\ttype_SYNTAX_%s, %s, %s},\n", 
		ot -> ot_text, ot -> ot_id, 
		ot -> ot_syntax == NULLOS ? "NULLOS" : 
			ot -> ot_syntax -> os_name,
		v_access (ot -> ot_access), v_status (ot -> ot_status));
    fprintf (cfp, "\t{ NULL, NULL,\n\t\ttype_SYNTAX_NULLOS, 0, 0},\n};\n\n");

    /* init_objects subroutine */
    fprintf (cfp, "int\ninit_objects()\n{\n");
    fprintf (cfp, "\treturn (importobjects (table_MIB_iobjects, syntax));\n}\n\n");
    return OK;
}

